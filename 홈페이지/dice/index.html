<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì£¼ì‚¬ìœ„ ë³´ë“œê²Œì„</title>
  <style>
/* ğŸ¯ ì£¼ì‚¬ìœ„ ì˜† ì¹˜íŠ¸ ì»¤ë§¨ë“œ ì…ë ¥ */
.cheat-input {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  margin-left: 6px; /* ì¹˜íŠ¸ ë°°ì§€ë‘ ì‚´ì§ ë„ìš°ê¸° */
}

.cheat-input input {
  width: 90px;
  padding: 2px 6px;
  border-radius: 999px;
  border: 1px solid #d4d4d8;
  font-size: 12px;
  background: #f9fafb;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  margin: 0;          /* ğŸ”¹ ë°”ê¹¥ ì—¬ë°± ì œê±° */
  padding: 20px;      /* ğŸ”¹ ëŒ€ì‹  ì•ˆìª½ ì—¬ë°±ìœ¼ë¡œ ë³€ê²½ */
  background: #f5f5f7;
}

    h1 {
      text-align: center;
      margin-bottom: 4px;
    }
/* ìš°ì£¼/ë„¤ì˜¨ í…Œë§ˆì—ì„œ
   - ì„¤ì •ì¤„(.config)ì€ í•­ìƒ ê²€ì€ìƒ‰
   - ìƒíƒœì¤„(.status)ì€ ê¸°ë³¸ ê¸€ì”¨ë§Œ ë°ê²Œ, í”Œë ˆì´ì–´ ì´ë¦„ì€ ë§ ìƒ‰ ê·¸ëŒ€ë¡œ ì‚¬ìš© */
body.theme-space .config,
body.theme-space .config *,
body.theme-neon .config,
body.theme-neon .config * {
  color: #111827 !important;   /* ì„¤ì •ì°½ë§Œ ê°•ì œë¡œ ê²€ì • */
}

/* ìš°ì£¼/ë„¤ì˜¨ í…Œë§ˆì—ì„œ ìƒíƒœì¤„ì€ í•­ìƒ ì§„í•œ ê¸€ì”¨ìƒ‰ ì‚¬ìš©
   (í”Œë ˆì´ì–´ ì´ë¦„ì€ JSê°€ inline styleë¡œ ìƒ‰ì„ ì£¼ê¸° ë•Œë¬¸ì— ê·¸ëŒ€ë¡œ ìœ ì§€ë¨) */
body.theme-space .status,
body.theme-space .status span,
body.theme-neon .status,
body.theme-neon .status span {
  color: #111827;
}





/* ìš°ì£¼/ë„¤ì˜¨ í…Œë§ˆì—ì„œ ìƒë‹¨ ì„¤ì • ì¤„(.config) ì•ˆ ê¸€ì”¨ëŠ” í•­ìƒ ê²€ì€ìƒ‰ */
body.theme-space .config,
body.theme-space .config *,
body.theme-neon .config,
body.theme-neon .config * {
  color: #111827 !important; /* ì§„í•œ ê²€ì •ì— ê°€ê¹Œìš´ ìƒ‰ */
}
    .game-container {
      max-width: 900px;
      margin: 0 auto;
      background: #ffffff;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      transition: transform 0.15s ease;
      position: relative;
      overflow: hidden;
    }

.top-panel {
  display: flex;
  flex-direction: column;   /* ìœ„: ìƒíƒœì°½, ì•„ë˜: ì£¼ì‚¬ìœ„ ë°•ìŠ¤ê°€ ì„¸ë¡œë¡œ ìŒ“ì´ë„ë¡ */
  align-items: center;      /* ë‘ ë°•ìŠ¤ë¥¼ ê°€ë¡œ ê°€ìš´ë° ì •ë ¬ */
  gap: 12px;
  margin-bottom: 16px;
  position: relative;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.4);
}


    .top-panel::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: -1px;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, #4f46e5, #22c55e, #f97316);
      opacity: 0.9;
    }

    .status-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(249, 250, 251, 0.9);
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      backdrop-filter: blur(8px);
    }

    .status {
      font-size: 14px;
      line-height: 1.4;
    }

    #currentPlayer {
      font-weight: 700;
    }

    .config {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      background: rgba(249, 250, 251, 0.9);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(209, 213, 219, 0.9);
    }

    .config select,
    .config input[type="number"],
    .config input[type="text"],
    .cell-range-edit input[type="text"] {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      font-size: 12px;
      background: #f9fafb;
      width: 70px;
    }

    .config input[type="text"],
    .cell-range-edit input[type="text"] {
      width: 140px;
    }

    /* ğŸ”§ ì¹¸ í¸ì§‘ ëª¨ë“œ ì•„ë˜ì— ë“¤ì–´ê°€ëŠ” ë²”ìœ„ ì…ë ¥ì°½ ìŠ¤íƒ€ì¼ */
    .cell-range-edit {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 11px;
    }

    .cell-range-edit label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .config label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .config button {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      background: #f3f4f6;
      cursor: pointer;
      font-size: 12px;
    }

    .config button:active {
      transform: translateY(1px);
    }

    .dice-box {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      position: relative;
      padding: 6px 10px;
      border-radius: 16px;
    }

    .dice-box::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background:
        radial-gradient(circle at 10% 0%, rgba(59, 130, 246, 0.18), transparent 55%),
        radial-gradient(circle at 90% 100%, rgba(244, 114, 182, 0.18), transparent 55%);
      z-index: -1;
    }

    .dice-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #rollBtn,
    #skipBtn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      color: #fff;
      transition: transform 0.05s ease, box-shadow 0.05s ease, opacity 0.2s ease;
    }

    #rollBtn {
      background: linear-gradient(135deg, #4f46e5, #6366f1);
    }

    #skipBtn {
      background: linear-gradient(135deg, #6b7280, #9ca3af);
    }

    #rollBtn:active,
    #skipBtn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.18);
    }

    #rollBtn:disabled,
    #skipBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .dice-visual {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      border: 2px solid #e5e7eb;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    
    /* ğŸ² êµ´ë¦¬ëŠ” ì¤‘ì¼ ë•Œ â€“ êµ´ëŸ¬ê°€ëŠ” ëª¨ì…˜ (ì‚´ì§ë§Œ) */
    .dice-visual.rolling {
      /* ì‚´ì§ ì˜¤ë¥¸ìª½ìœ¼ë¡œ êµ´ëŸ¬ê°€ë©´ì„œ 1ë°”í€´ë§Œ íšŒì „ */
      animation: dice-roll 0.7s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    @keyframes dice-roll {
      0% {
        transform: translateX(0px) translateY(0px) rotateZ(0deg);
      }
      20% {
        transform: translateX(6px) translateY(-3px) rotateZ(180deg);
      }
      50% {
        transform: translateX(10px) translateY(-1px) rotateZ(360deg);
      }
      80% {
        transform: translateX(4px) translateY(1px) rotateZ(540deg);
      }
      100% {
        transform: translateX(0px) translateY(0px) rotateZ(720deg);
      }
    }

    /* ì¹˜íŠ¸ ì£¼ì‚¬ìœ„: í´ë˜ìŠ¤ ìì²´ëŠ” ë„¤ì˜¨ ìŠ¤íƒ€ì¼ë§Œ í‘œì‹œ (ì• ë‹ˆë©”ì´ì…˜ì€ rolling ë•Œë§Œ ì ìš©) */
    .dice-visual.cheat-active {
      /* ì—¬ê¸°ì„œëŠ” ë³„ë„ transform ì• ë‹ˆë©”ì´ì…˜ì„ ê±¸ì§€ ì•ŠëŠ”ë‹¤ */
    }

    /* ì¹˜íŠ¸ + êµ´ë¦¬ëŠ” ì¤‘ì¼ ë•Œ: ë™ì¼í•œ êµ´ë¦¼ + ë°•ìŠ¤ ê·¸ë¦¼ìë§Œ ì‚´ì§ ë°˜ì§ì„ */
    .dice-visual.rolling.cheat-active {
      animation:
        dice-roll 0.7s cubic-bezier(0.25, 0.8, 0.25, 1),
        cheat-glow 0.7s ease-out;
    }

    @keyframes cheat-glow {
      0% {
        box-shadow:
          0 4px 10px rgba(0, 0, 0, 0.06),
          0 0 0px rgba(250, 204, 21, 0.0);
      }
      40% {
        box-shadow:
          0 4px 12px rgba(0, 0, 0, 0.10),
          0 0 14px rgba(250, 204, 21, 0.85);
      }
      100% {
        box-shadow:
          0 4px 10px rgba(0, 0, 0, 0.06),
          0 0 0px rgba(250, 204, 21, 0.0);
      }
    }

.dice-pip-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 100%;
      height: 100%;
      gap: 2px;
    }

    .dice-cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dice-pip {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: currentColor;
    }

    .dice-value {
      font-size: 12px;
      max-width: 260px;
      text-align: right;
      display: none;
    }

    .cheat-badge {
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      font-size: 13px;
      font-weight: 700;
      white-space: nowrap;
    }

    .cheat-badge span {
      font-weight: 600;
      color: #4b5563;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 4px;
      margin-top: 8px;
    }

    .cell {
      position: relative;
      border-radius: 10px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      min-height: 60px;
      padding: 4px;
      box-sizing: border-box;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: box-shadow 0.2s ease, transform 0.2s ease;
      cursor: pointer;
    }
/* ===== íŠ¹ìˆ˜ ì¹¸ ì•„ì´ì½˜ + ë°˜ì§ íš¨ê³¼ ===== */
.cell.zone-boost::after,
.cell.zone-slow::after,
.cell.zone-reset::after,
.cell.zone-gkey::after {
  position: absolute;
  right: 6px;
  top: 4px;
  font-size: 14px;
  opacity: 0.9;
}

/* ì•„ì´ì½˜ ëª¨ì–‘ */
.cell.zone-boost::after { content: "âš¡"; }   /* x2 ì¹¸ */
.cell.zone-slow::after  { content: "ğŸ¢"; }   /* 1/2 ì¹¸ */
.cell.zone-reset::after { content: "â˜ "; }   /* í•¨ì • ì¹¸ */
.cell.zone-gkey::after  { content: "ğŸ”‘"; }   /* í™©ê¸ˆì—´ì‡  ì¹¸ */

/* ì€ì€í•œ ë„¤ì˜¨ í…Œë‘ë¦¬ */
.cell.zone-boost {
  box-shadow: 0 0 10px rgba(239, 68, 68, 0.35);
}
.cell.zone-slow {
  box-shadow: 0 0 10px rgba(59, 130, 246, 0.35);
}
.cell.zone-reset {
  box-shadow: 0 0 10px rgba(234, 179, 8, 0.45);
}
.cell.zone-gkey {
  box-shadow: 0 0 12px rgba(168, 85, 247, 0.6);
}

    .cell:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.14);
    }

    .cell-index {
      font-weight: 600;
      opacity: 0.7;
    }

    .cell-zone-label {
      font-size: 10px;
      opacity: 0.9;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .cell-zone-label::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #9ca3af;
    }

    .token-container {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .token {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-sizing: border-box;
      transition: transform 0.1s ease;
    }

    .zone-boost {
      background: #ffeaea;
      border-color: #ffb3b3;
    }
    .zone-boost .cell-zone-label::before {
      background: #ef4444;
    }

    .zone-slow {
      background: #e8f0ff;
      border-color: #b3c6ff;
    }
    .zone-slow .cell-zone-label::before {
      background: #3b82f6;
    }

    .zone-reset {
      background: #fef3c7;
      border-color: #facc15;
    }
    .zone-reset .cell-zone-label::before {
      background: #facc15;
    }

    .zone-gkey {
      background: #f5f3ff;
      border-color: #a855f7;
    }
    .zone-gkey .cell-zone-label::before {
      background: #a855f7;
    }

    .cell.start-cell {
      border: 2px solid #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
      background: #ecfdf5;
    }

    .cell.finish-cell {
      border: 2px solid #f97316;
      box-shadow: 0 0 12px rgba(249, 115, 22, 0.7);
      background: #fff7ed;
    }

    .legend {
      margin-top: 10px;
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    .legend-color.boost {
      background: #ffeaea;
      border-color: #ffb3b3;
    }

    .legend-color.slow {
      background: #e8f0ff;
      border-color: #b3c6ff;
    }

    .legend-color.reset {
      background: #fef3c7;
      border-color: #facc15;
    }

    .legend-color.gkey {
      background: #f5f3ff;
      border-color: #a855f7;
    }

    .players-legend {
      font-size: 12px;
      margin-top: 6px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .player-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f3f4f6;
      border: 1px solid transparent;
      transition: border 0.1s ease, background 0.1s ease;
    }

    .player-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .player-pill.current-turn {
      border: 2px solid #111827;
      background: #e0f2fe;
    }

    .token.current-turn {
      transform: scale(1.2);
      animation: pulse 0.8s ease-in-out infinite;
    }

    @keyframes pulse {
      0%   { transform: scale(1.0); }
      50%  { transform: scale(1.3); }
      100% { transform: scale(1.0); }
    }

    .log-box {
      margin-top: 14px;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      background: #f9fafb;
      border-radius: 10px;
      padding: 8px;
      border: 1px solid #e5e7eb;
    }

    .log-entry {
      margin-bottom: 4px;
    }

    /* ê³µí†µ ì˜¤ë²„ë ˆì´ (í™©ê¸ˆì—´ì‡ /ì¹˜íŠ¸) */
    #goldenKeyOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.55);
      z-index: 9998;
      pointer-events: none;
      opacity: 0;
    }

    #goldenKeyOverlay.show {
      display: flex;
      animation-name: overlayFade;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes overlayFade {
      0%   { opacity: 0; }
      20%  { opacity: 1; }
      80%  { opacity: 1; }
      100% { opacity: 0; }
    }

    #goldenKeyPopup,
    #cheatPopup {
      padding: 16px 26px;
      border-radius: 999px;
      font-size: 24px;
      font-weight: 800;
      display: none;
      align-items: center;
      gap: 10px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      z-index: 9999;
      transform: scale(0.4);
      opacity: 0;
    }

    #goldenKeyPopup {
      position: relative;
      background: rgba(250, 204, 21, 0.97);
      color: #78350f;
      font-size: 28px;
    }

    #cheatPopup {
      position: relative;
      background: rgba(249, 250, 251, 0.95);
      color: #111827;
    }

    #goldenKeyPopup.show,
    #cheatPopup.show {
      display: flex;
      animation-name: gkey-pop;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes gkey-pop {
      0% {
        opacity: 0;
        transform: scale(0.2);
      }
      30% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(1.1);
      }
    }

    .sparkle {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle, #fefce8 0%, #facc15 40%, transparent 70%);
      opacity: 0;
      box-shadow: 0 0 14px rgba(250, 250, 170, 0.9);
      pointer-events: none;
      animation-name: sparkleBlink;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes sparkleBlink {
      0%   { transform: scale(0.2); opacity: 0; }
      30%  { transform: scale(1.3); opacity: 1; }
      70%  { transform: scale(0.9); opacity: 0.9; }
      100% { transform: scale(0.4); opacity: 0; }
    }

    .token.token-fast {
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
      animation: fastMove 0.2s linear infinite;
    }

    @keyframes fastMove {
      0%   { transform: scale(1.15) translateX(-1px); }
      50%  { transform: scale(1.25) translateX(1px); }
      100% { transform: scale(1.15) translateX(-1px); }
    }

    .cell.landing {
      animation: landingFlash 0.35s ease-out;
    }

    @keyframes landingFlash {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(250, 204, 21, 0);
      }
      50% {
        transform: scale(1.03);
        box-shadow: 0 0 12px rgba(250, 204, 21, 0.9);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(250, 204, 21, 0);
      }
    }

    .game-container.shake {
      animation: shakeBoard 0.4s ease;
    }

    @keyframes shakeBoard {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-4px); }
      40%  { transform: translateX(4px); }
      60%  { transform: translateX(-3px); }
      80%  { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    @media (max-width: 600px) {
      .cell {
        min-height: 48px;
      }
      .board {
        grid-template-columns: repeat(6, 1fr);
      }
      .dice-value {
        max-width: 200px;
      }
      .dice-row {
        flex-wrap: wrap;
      }
      #goldenKeyPopup {
        font-size: 22px;
        padding: 12px 18px;
      }
      #cheatPopup {
        font-size: 20px;
        padding: 10px 16px;
      }
    }

    /* ===================== */
    /*   í…Œë§ˆë³„ ìƒ‰ìƒ ìŠ¤í‚¨    */
    /* ===================== */

    body.theme-default {
    }

    body.theme-space {
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000000 100%);
      color: #e5e7eb;
    }
    body.theme-space .game-container {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
    }
    body.theme-space .cell {
      background: #020617;
      border-color: #1f2937;
    }
    body.theme-space .zone-boost {
      background: rgba(8, 47, 73, 0.9);
      border-color: #38bdf8;
    }
    body.theme-space .zone-slow {
      background: rgba(30, 64, 175, 0.9);
      border-color: #a5b4fc;
    }
    body.theme-space .zone-reset {
      background: rgba(127, 29, 29, 0.9);
      border-color: #f97373;
    }
    body.theme-space .zone-gkey {
      background: rgba(88, 28, 135, 0.95);
      border-color: #fbbf24;
    }
    body.theme-space .log-box {
      background: rgba(15, 23, 42, 0.9);
      border-color: #1f2937;
    }
/* ìš°ì£¼ í…Œë§ˆ: ëˆ„êµ¬ ì°¨ë¡€ì¸ì§€ ë” ëˆˆì— ë„ê²Œ */
body.theme-space .players-legend .player-pill {
  background: transparent;          /* ê¸°ë³¸ì€ ë°°ê²½ íˆ¬ëª… */
  border-color: transparent;
  color: #e5e7eb;                   /* ê¸€ì”¨ëŠ” ë°ê²Œ */
}

/* ìš°ì£¼ í…Œë§ˆì—ì„œ í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ pill */
body.theme-space .players-legend .player-pill.current-turn {
  background: #0b1120;              /* ì§„í•œ ë‚¨ìƒ‰ ìº¡ìŠ */
  border-color: #facc15;            /* í™©ê¸ˆìƒ‰ í…Œë‘ë¦¬ */
  box-shadow:
    0 0 0 2px rgba(248, 250, 252, 0.9),
    0 0 12px rgba(250, 204, 21, 0.85);  /* ì‚´ì§ ë¹›ë‚˜ëŠ” íš¨ê³¼ */
}


    body.theme-forest {
      background:
        linear-gradient(to top, #bbf7d0 0%, #86efac 35%, #22c55e 38%, #16a34a 41%, #14532d 43%),
        linear-gradient(to top, #bbf7d0 0%, #bbf7d0 42%, #e0f2fe 80%, #bfdbfe 100%);
    }
    body.theme-forest .game-container {
      background: #ecfdf5;
    }
    body.theme-forest .cell {
      background: #d1fae5;
      border-color: #6ee7b7;
    }
    body.theme-forest .zone-boost {
      background: #bbf7d0;
      border-color: #22c55e;
    }
    body.theme-forest .zone-slow {
      background: #a7f3d0;
      border-color: #22c55e;
    }
    body.theme-forest .zone-reset {
      background: #fef3c7;
      border-color: #f97316;
    }
    body.theme-forest .zone-gkey {
      background: #f5f3ff;
      border-color: #4c1d95;
    }
    body.theme-forest .log-box {
      background: #f0fdf4;
      border-color: #bbf7d0;
    }
    body.theme-forest .players-legend .player-pill {
      background: #dcfce7;
    }

    body.theme-desert {
      background: linear-gradient(135deg, #f97316, #facc15);
    }
    body.theme-desert .game-container {
      background: #fffbeb;
    }
    body.theme-desert .cell {
      background: #fef3c7;
      border-color: #fbbf24;
    }
    body.theme-desert .zone-boost {
      background: #fed7aa;
      border-color: #f97316;
    }
    body.theme-desert .zone-slow {
      background: #fee2e2;
      border-color: #f87171;
    }
    body.theme-desert .zone-reset {
      background: #fee2e2;
      border-color: #b91c1c;
    }
    body.theme-desert .zone-gkey {
      background: #fef9c3;
      border-color: #a16207;
    }
    body.theme-desert .log-box {
      background: #fffbeb;
      border-color: #facc15;
    }
    body.theme-desert .players-legend .player-pill {
      background: #fffbeb;
    }

    body.theme-neon {
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000000 100%);
      color: #e5e7eb;
    }
    body.theme-neon .game-container {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
    }
    body.theme-neon .cell {
      background: #020617;
      border-color: #4c1d95;
      box-shadow: 0 0 0 1px rgba(139, 92, 246, 0.3);
    }
    body.theme-neon .zone-boost {
      background: rgba(8, 47, 73, 0.9);
      border-color: #22d3ee;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.7);
    }
    body.theme-neon .zone-slow {
      background: rgba(76, 29, 149, 0.9);
      border-color: #a855f7;
      box-shadow: 0 0 15px rgba(168, 85, 247, 0.7);
    }
    body.theme-neon .zone-reset {
      background: rgba(127, 29, 29, 0.95);
      border-color: #fb7185;
      box-shadow: 0 0 15px rgba(248, 113, 113, 0.7);
    }
    body.theme-neon .zone-gkey {
      background: rgba(250, 204, 21, 0.95);
      border-color: #f97316;
      box-shadow: 0 0 18px rgba(250, 204, 21, 0.8);
    }
    body.theme-neon .log-box {
      background: rgba(15, 23, 42, 0.95);
      border-color: #4c1d95;
    }
/* ë„¤ì˜¨ í…Œë§ˆ: í˜„ì¬ í„´ pill ê°•ì¡° */
body.theme-neon .players-legend .player-pill {
  background: rgba(15, 23, 42, 0.7);
  border-color: transparent;
  color: #e5e7eb;
}

body.theme-neon .players-legend .player-pill.current-turn {
  background: #020617;
  border-color: #22d3ee;              /* ì‹œì•ˆìƒ‰ í…Œë‘ë¦¬ */
  box-shadow:
    0 0 0 2px rgba(244, 244, 245, 0.9),
    0 0 14px rgba(56, 189, 248, 0.9);
}


    h1 {
      text-align: center;
      margin-bottom: 6px;
      font-size: 28px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: linear-gradient(120deg, #4f46e5, #ec4899, #f97316);
      -webkit-background-clip: text;
      color: transparent;
      filter: drop-shadow(0 2px 6px rgba(15, 23, 42, 0.25));
    }

    .game-container::before {
      content: "";
      position: absolute;
      inset: -2px;
      border-radius: inherit;
      background: linear-gradient(
        135deg,
        rgba(79, 70, 229, 0.55),
        rgba(14, 165, 233, 0.45),
        rgba(236, 72, 153, 0.55)
      );
      opacity: 0.7;
      z-index: -1;
    }
  
        /* ì¹¸ í¸ì§‘ íŒ¨ë„ (ì¹´ë“œí˜• ë””ìì¸) */
    .cell-edit-card {
      margin-top: 10px;
      margin-bottom: 6px;
      padding: 8px 10px;
      border-radius: 12px;
      background: linear-gradient(135deg, #f9fafb, #eef2ff);
      border: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    /* ğŸ”½ ì¹¸ í¸ì§‘ ëª¨ë“œ ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ */
    .cell-edit-toggle {
      margin-left: 8px;             /* ì œëª© ì˜¤ë¥¸ìª½ì— ì‚´ì§ë§Œ ë„ìš°ê¸° */
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      background: #e5e7eb;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
    }


    /* ì ‘íŒ ìƒíƒœì—ì„œëŠ” ë‚´ìš©(body)ë§Œ ìˆ¨ê¹€ */
    .cell-edit-card.collapsed .cell-edit-body {
      display: none;
    }



    .cell-edit-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;  /* ì œëª© + ë²„íŠ¼ì„ ì™¼ìª½ì— ëª¨ìœ¼ê¸° */
      column-gap: 8px;              /* ê°€ë¡œ ê°„ê²© */
      row-gap: 4px;                 /* ì„¸ë¡œ ê°„ê²© */
    }

    .cell-edit-title {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 700;
      font-size: 12px;
      color: #111827;
    }

    .cell-edit-title-icon {
      font-size: 14px;
    }

    .cell-edit-sub {
      font-size: 11px;
      color: #6b7280;
      flex-basis: 100%;     /* ì œëª©/ë²„íŠ¼ ì•„ë˜ ì¤„ ì „ì²´ë¥¼ ì°¨ì§€í•˜ê²Œ */
      margin-left: 22px;    /* ì•„ì´ì½˜/ì œëª© ë°‘ìœ¼ë¡œ ì‚´ì§ ë“¤ì—¬ì“°ê¸° */
    }


    .cell-edit-panel {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
      margin-top: 2px;
    }

    .cell-edit-btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      background: white;
      cursor: pointer;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.04);
    }

    .cell-edit-btn:hover {
      border-color: #4f46e5;
    }

    .cell-edit-btn.active {
      background: linear-gradient(135deg, #4f46e5, #2563eb);
      color: #f9fafb;
      border-color: #4338ca;
      box-shadow: 0 0 0 1px rgba(191, 219, 254, 0.7),
        0 4px 8px rgba(37, 99, 235, 0.35);
    }

    .cell-edit-btn-icon {
      font-size: 12px;
    }

    .cell-edit-hint {
      font-size: 11px;
      color: #6b7280;
    }

    /* === ìš°ì£¼/ë„¤ì˜¨ í…Œë§ˆì—ì„œ ì¼ë°˜ ì£¼ì‚¬ìœ„ë¥¼ ë” ë°ê²Œ ë³´ì´ë„ë¡ ê°•ì œ === */
    body.theme-space .dice-visual:not(.cheat-active),
    body.theme-neon .dice-visual:not(.cheat-active) {
      background: #ffffff !important;      /* ì•ˆìª½ ì™„ì „ í°ìƒ‰ */
      border-color: #e5e7eb;
      color: #020617;
      box-shadow:
        0 0 0 2px rgba(15, 23, 42, 0.9),
        0 0 20px rgba(255, 255, 255, 0.95); /* ì‚¬ë°©ìœ¼ë¡œ í° ë¹› */
    }

    body.theme-space .dice-visual:not(.cheat-active) .dice-pip,
    body.theme-neon .dice-visual:not(.cheat-active) .dice-pip {
      background: #020617;  /* ëˆˆì€ ì§™ì€ ìƒ‰ìœ¼ë¡œ ë˜ë ·í•˜ê²Œ */
    }

    /* ğŸŒŸ ë„¤ì˜¨ í…Œë§ˆ í™©ê¸ˆì—´ì‡  ì¹¸ ìƒ‰ì„ ë” ì—°í•˜ê²Œ ì¡°ì • */
    body.theme-neon .zone-gkey {
      background: rgba(254, 252, 232, 0.96); /* ì•„ì£¼ ì˜…ì€ íŒŒìŠ¤í…” ë…¸ë‘ */
      border-color: #fde68a;                 /* ì—°í•œ í…Œë‘ë¦¬ */
      color: #1f2937;                        /* ì§„í•œ ê¸€ììƒ‰ìœ¼ë¡œ ëŒ€ë¹„ */
      box-shadow: 0 0 10px rgba(250, 204, 21, 0.45);
    }

    /* ğŸŒŸ ë„¤ì˜¨ í…Œë§ˆ í™©ê¸ˆì—´ì‡  ì¹¸ì— ë„¤ì˜¨ ëŠë‚Œ ì¶”ê°€ (ì—°í•œ ë°”íƒ• + ê°•í•œ ì™¸ê³½ ê¸€ë¡œìš°) */
    body.theme-neon .zone-gkey {
      background: rgba(254, 252, 232, 0.96); /* ì—°í•œ íŒŒìŠ¤í…” ë…¸ë‘ ìœ ì§€ */
      border-color: #facc15;                 /* ì‚´ì§ ë” ì§„í•œ ê³¨ë“œ í…Œë‘ë¦¬ */
      color: #1f2937;                        /* ê¸€ìëŠ” ì§„í•œ ìƒ‰ìœ¼ë¡œ ì„ ëª…í•˜ê²Œ */
      box-shadow:
        0 0 4px rgba(250, 204, 21, 0.7),
        0 0 14px rgba(250, 204, 21, 0.9),
        0 0 28px rgba(250, 249, 150, 0.9);   /* ë°”ê¹¥ìª½ìœ¼ë¡œ í¼ì§€ëŠ” ë„¤ì˜¨ ê´‘ì±„ */
    }

    /* ğŸŒŸ ë„¤ì˜¨ í…Œë§ˆ í™©ê¸ˆì—´ì‡  ì¹¸ ë„¤ì˜¨ ê´‘ì±„ë¥¼ ì¡°ê¸ˆë§Œ ì¤„ì¸ ë²„ì „ */
    body.theme-neon .zone-gkey {
      background: rgba(254, 252, 232, 0.96); /* ì—°í•œ íŒŒìŠ¤í…” ë…¸ë‘ ìœ ì§€ */
      border-color: #facc15;                 /* ê³¨ë“œ í…Œë‘ë¦¬ ìœ ì§€ */
      color: #1f2937;                        /* ì§„í•œ ê¸€ììƒ‰ ìœ ì§€ */
      box-shadow:
        0 0 3px rgba(250, 204, 21, 0.55),
        0 0 12px rgba(250, 249, 150, 0.65);  /* ê¸°ì¡´ë³´ë‹¤ ë°˜ê²½ê³¼ ê°•ë„ ëª¨ë‘ ì‚´ì§ ê°ì†Œ */
    }

    /* ğŸŒŸ ë„¤ì˜¨ í…Œë§ˆ í™©ê¸ˆì—´ì‡  ì¹¸: í…Œë‘ë¦¬ëŠ” ë” ì§„í•˜ê²Œ, ì•ˆìª½ì€ ì‚´ì§ ë” ì—°í•˜ê²Œ, ë„¤ì˜¨ ê´‘ì±„ëŠ” ì¡°ê¸ˆë§Œ ê°•í™” */
    body.theme-neon .zone-gkey {
      background: rgba(255, 253, 244, 0.97); /* ë” ë°ì€ í¬ë¦¼ìƒ‰ ëŠë‚Œ */
      border-color: #eab308;                 /* í•œ í†¤ ë” ì§„í•œ ê³¨ë“œ í…Œë‘ë¦¬ */
      color: #1f2937;                        /* ê¸€ìëŠ” ê·¸ëŒ€ë¡œ ì„ ëª…í•˜ê²Œ */
      box-shadow:
        0 0 4px rgba(250, 204, 21, 0.6),
        0 0 14px rgba(250, 249, 150, 0.72);  /* ì§ì „ë³´ë‹¤ ì‚´ì§ë§Œ ë” ê°•í•´ì§„ ë„¤ì˜¨ */
    }

    /* ğŸ’¡ ë„¤ì˜¨ í…Œë§ˆ: ì´ë¯¸ì§€ ì—†ì´ ë„¤ì˜¨ ê²©ì + ë¹›ë‚˜ëŠ” ì¤‘ì‹¬ë¶€ í‘œí˜„ */
    body.theme-neon::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(circle at center,
          rgba(52, 211, 153, 0.20),
          transparent 55%),
        radial-gradient(circle at top,
          rgba(59, 130, 246, 0.20),
          transparent 60%),
        linear-gradient(rgba(56, 189, 248, 0.24) 1px, transparent 1px),
        linear-gradient(90deg, rgba(236, 72, 153, 0.24) 1px, transparent 1px);
      background-size:
        100% 100%,
        100% 100%,
        48px 48px,
        48px 48px;
      opacity: 0.55;
      mix-blend-mode: screen;
    }

    /* ğŸŒŒ ìš°ì£¼ í…Œë§ˆ: ë³„ì„ ë” ë§ê³  ë°ê²Œ (CSSë§Œ ì‚¬ìš©, ê¸°ì¡´ë³´ë‹¤ ë°€ë„/ë°ê¸° ì¦ê°€) */
    body.theme-space::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(2px 2px at 10% 15%, rgba(248, 250, 252, 1.0), transparent 55%),
        radial-gradient(1.5px 1.5px at 25% 30%, rgba(226, 232, 240, 1.0), transparent 55%),
        radial-gradient(2.2px 2.2px at 40% 20%, rgba(248, 250, 252, 1.0), transparent 55%),
        radial-gradient(1.8px 1.8px at 65% 18%, rgba(226, 232, 240, 1.0), transparent 55%),
        radial-gradient(1.6px 1.6px at 80% 28%, rgba(248, 250, 252, 1.0), transparent 55%),
        radial-gradient(2px 2px at 20% 65%, rgba(226, 232, 240, 1.0), transparent 55%),
        radial-gradient(1.5px 1.5px at 50% 75%, rgba(248, 250, 252, 1.0), transparent 55%),
        radial-gradient(2px 2px at 72% 68%, rgba(226, 232, 240, 1.0), transparent 55%),
        radial-gradient(1.4px 1.4px at 88% 82%, rgba(248, 250, 252, 1.0), transparent 55%),
        radial-gradient(1.2px 1.2px at 15% 85%, rgba(226, 232, 240, 1.0), transparent 55%),
        radial-gradient(2.4px 2.4px at 55% 10%, rgba(248, 250, 252, 1.0), transparent 55%);
      opacity: 1.0;
      mix-blend-mode: screen;
    }

    /* ğŸ’¡ ë„¤ì˜¨ í…Œë§ˆ: ê²©ì ì‚­ì œ, ì¢Œìš°ì—ì„œ ë¹„ì¶”ëŠ” ë„¤ì˜¨ ê´‘ì› ëŠë‚Œë§Œ */
    body.theme-neon::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(circle at 0% 50%, rgba(236, 72, 153, 0.40), transparent 60%),
        radial-gradient(circle at 100% 50%, rgba(56, 189, 248, 0.40), transparent 60%);
      background-size: 100% 100%;
      opacity: 0.75;
      mix-blend-mode: screen;
    }

    /* ğŸŒŒ ìš°ì£¼ í…Œë§ˆ: ë³„ì„ í›¨ì”¬ ë” ë°ê³  ë˜ë ·í•˜ê²Œ (ê°•í•œ í™”ì´íŠ¸ í¬ì¸íŠ¸) */
    body.theme-space::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(2.4px 2.4px at 8% 12%,  rgba(255, 255, 255, 1.0), transparent 60%),
        radial-gradient(2.2px 2.2px at 22% 26%, rgba(248, 250, 252, 0.98), transparent 60%),
        radial-gradient(2.6px 2.6px at 38% 18%, rgba(255, 255, 255, 1.0), transparent 60%),
        radial-gradient(2.4px 2.4px at 61% 16%, rgba(248, 250, 252, 0.98), transparent 60%),
        radial-gradient(2.2px 2.2px at 78% 24%, rgba(255, 255, 255, 1.0), transparent 60%),
        radial-gradient(2.4px 2.4px at 18% 60%, rgba(248, 250, 252, 0.98), transparent 60%),
        radial-gradient(2.2px 2.2px at 46% 72%, rgba(255, 255, 255, 1.0), transparent 60%),
        radial-gradient(2.4px 2.4px at 70% 66%, rgba(248, 250, 252, 0.98), transparent 60%),
        radial-gradient(2.2px 2.2px at 88% 78%, rgba(255, 255, 255, 1.0), transparent 60%),
        radial-gradient(2.0px 2.0px at 14% 82%, rgba(248, 250, 252, 0.95), transparent 60%),
        radial-gradient(2.8px 2.8px at 52% 10%, rgba(255, 255, 255, 1.0), transparent 60%);
      opacity: 1.0;              /* ì™„ì „í•œ ë°ê¸° */
      mix-blend-mode: screen;    /* ì–´ë‘ìš´ ë°°ê²½ ìœ„ì—ì„œ í•˜ì–€ ë³„ì´ ì˜ ë³´ì´ë„ë¡ */
    }
/* ğŸŒŒ ìš°ì£¼ í…Œë§ˆ: ë³„ 100ê°œ ì •ë„ (ê°€ë²¼ìš´ ë²„ì „) */
body.theme-space::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: -1;
  opacity: 0.95;
  mix-blend-mode: screen;
  background-image:
    radial-gradient(1.8px 1.8px at 10% 10%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 25% 18%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.6px 1.6px at 40% 14%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.9px 1.9px at 60% 12%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.5px 1.5px at 78% 20%, rgba(226, 232, 240, 1.0), transparent 60%),

    radial-gradient(1.4px 1.4px at 15% 30%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.8px 1.8px at 35% 32%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.3px 1.3px at 55% 28%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.7px 1.7px at 72% 35%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 90% 30%, rgba(255, 255, 255, 1.0), transparent 60%),

    radial-gradient(1.5px 1.5px at 8% 45%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.9px 1.9px at 27% 46%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 45% 42%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.6px 1.6px at 63% 48%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.3px 1.3px at 82% 44%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.8px 1.8px at 96% 40%, rgba(255, 255, 255, 1.0), transparent 60%),

    radial-gradient(1.4px 1.4px at 12% 60%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.7px 1.7px at 30% 63%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.3px 1.3px at 48% 58%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.9px 1.9px at 67% 62%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 83% 59%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.6px 1.6px at 94% 55%, rgba(255, 255, 255, 1.0), transparent 60%),

    radial-gradient(1.5px 1.5px at 6% 75%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.8px 1.8px at 22% 78%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.3px 1.3px at 38% 72%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.7px 1.7px at 56% 80%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 72% 75%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.9px 1.9px at 88% 78%, rgba(255, 255, 255, 1.0), transparent 60%),

    radial-gradient(1.6px 1.6px at 12% 90%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.4px 1.4px at 30% 92%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.8px 1.8px at 48% 88%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(1.5px 1.5px at 66% 93%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(1.7px 1.7px at 82% 88%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(1.6px 1.6px at 95% 85%, rgba(255, 255, 255, 1.0), transparent 60%);
   opacity: 1.0;
   filter: brightness(3.0) drop-shadow(0 0 4px white);
   mix-blend-mode: screen;
}
    /* ğŸŒ² ìˆ² í…Œë§ˆ: ìœ„ì—ì„œ ë¹„ì¹˜ëŠ” í–‡ì‚´ + ì—°ë‘/ì—ë©”ë„ë“œ ëŠë‚Œ */
    body.theme-forest::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(circle at top left,  rgba(190, 242, 100, 0.35), transparent 60%),
        radial-gradient(circle at top right, rgba(45, 212, 191, 0.30), transparent 65%),
        radial-gradient(circle at bottom,    rgba(34, 197, 94, 0.30), transparent 70%);
      opacity: 0.9;
      mix-blend-mode: soft-light;
    }

    /* ğŸœ ì‚¬ë§‰ í…Œë§ˆ: ëª¨ë˜ ì–¸ë• ìœ„ë¡œ ë–¨ì–´ì§€ëŠ” í–‡ë¹› ëŠë‚Œ */
    body.theme-desert::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        radial-gradient(circle at top,    rgba(253, 224, 171, 0.50), transparent 60%),
        radial-gradient(circle at 20% 70%,rgba(251, 191, 36, 0.35),  transparent 65%),
        radial-gradient(circle at 80% 80%,rgba(248, 250, 252, 0.30), transparent 70%);
      opacity: 0.95;
      mix-blend-mode: soft-light;
    }

    /* ğŸŒ² ìˆ² í…Œë§ˆ: ë‚˜ë¬´ ì¤„ê¸° + ìœ—ë¶€ë¶„ ìˆ˜ê´€ ëŠë‚Œ (ì´ë¯¸ì§€ ì—†ì´ CSSë¡œ í‘œí˜„) */
    body.theme-forest::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        /* ìœ„ìª½ ìˆ˜ê´€(ë‚˜ë­‡ì ë©ì–´ë¦¬) */
        radial-gradient(circle at top, rgba(74, 222, 128, 0.45), transparent 60%),
        radial-gradient(circle at 20% 10%, rgba(52, 211, 153, 0.45), transparent 55%),
        radial-gradient(circle at 80% 12%, rgba(34, 197, 94, 0.45), transparent 55%),
        /* ì„¸ë¡œë¡œ ë°˜ë³µë˜ëŠ” ë‚˜ë¬´ ì¤„ê¸°ë“¤ */
        repeating-linear-gradient(
          90deg,
          rgba(15, 23, 42, 0.0) 0px,
          rgba(15, 23, 42, 0.0) 26px,
          rgba(15, 23, 42, 0.55) 26px,
          rgba(15, 23, 42, 0.55) 33px
        );
      background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%;
      opacity: 0.9;
      mix-blend-mode: soft-light;
    }

    /* ğŸŒ² ìˆ² í…Œë§ˆ (ì†Œí”„íŠ¸ ë²„ì „): ì„¸ë¡œ ì¤„ë¬´ëŠ¬ ì œê±°, ìœ—ë¶€ë¶„ ìˆ˜ê´€ + ë°”ë‹¥ ëŠë‚Œë§Œ ë‚¨ê¹€ */
    body.theme-forest::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background-image:
        /* ìœ„ìª½ ìˆ˜ê´€(ë‚˜ë­‡ì) */
        radial-gradient(circle at top,     rgba(74, 222, 128, 0.45), transparent 60%),
        radial-gradient(circle at 15% 0%,  rgba(52, 211, 153, 0.40), transparent 55%),
        radial-gradient(circle at 85% 0%,  rgba(34, 197, 94, 0.40), transparent 55%),
        /* ì•„ë˜ìª½ ìˆ² ë°”ë‹¥/ê·¸ëŠ˜ */
        radial-gradient(circle at 50% 100%, rgba(15, 118, 110, 0.55), transparent 65%),
        radial-gradient(circle at 20% 100%, rgba(4, 120, 87, 0.45), transparent 70%),
        radial-gradient(circle at 80% 100%, rgba(6, 95, 70, 0.45), transparent 70%),
        /* ì‚´ì§ ë“¤ì–´ì˜¤ëŠ” í–‡ì‚´ */
        linear-gradient(135deg, rgba(255, 255, 255, 0.06), transparent 55%);
      background-size: 100% 100%;
      opacity: 0.9;
      mix-blend-mode: soft-light;
    }

/* ğŸ”¤ ìš°ì£¼/ë„¤ì˜¨ í…Œë§ˆì—ì„œë„ ì¹¸ í¸ì§‘ ì˜ì—­ ê¸€ì”¨ëŠ” í•­ìƒ ì§„í•œ ìƒ‰ìœ¼ë¡œ */
body.theme-space .cell-edit-card,
body.theme-space .cell-edit-card * {
  color: #111827;
}

body.theme-neon .cell-edit-card,
body.theme-neon .cell-edit-card * {
  color: #111827;
}

/* âœ… ë‹¨, í™œì„±í™”ëœ ë²„íŠ¼ì€ í° ê¸€ì”¨ ìœ ì§€ (íŒŒë€ ê·¸ë¼ë°ì´ì…˜ ë²„íŠ¼) */
body.theme-space .cell-edit-btn.active,
body.theme-neon .cell-edit-btn.active {
  color: #f9fafb;
}
/* === ë°°ê²½ ì ˆë‹¨ í˜„ìƒ ìˆ˜ì •ìš© â€“ ìˆ²/ì‚¬ë§‰ ë°°ê²½ ë‹¤ì‹œ ì •ì˜ === */

/* ìˆ² í…Œë§ˆ: ìœ„ëŠ” ì§™ì€ ìˆ², ì•„ë˜ë¡œ ê°ˆìˆ˜ë¡ ë°ì€ ì´ˆë¡ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ */
body.theme-forest {
  background: linear-gradient(
    to bottom,
    #14532d 0%,   /* ê°€ì¥ ìœ„ â€“ ì§„í•œ ìˆ² ì´ˆë¡ */
    #166534 30%,  /* ì¤‘ê°„ ìœ„ìª½ */
    #22c55e 60%,  /* ì¤‘ê°„ â€“ ì„ ëª…í•œ ì´ˆë¡ */
    #bbf7d0 100%  /* ë§¨ ì•„ë˜ â€“ ë°ì€ ì—°ë‘ */
  );
  background-repeat: no-repeat;
  background-attachment: fixed;
}

/* (ì˜µì…˜) ì‚¬ë§‰ í…Œë§ˆë„ í˜¹ì‹œ ë¹„ìŠ·í•˜ê²Œ ëŠê»´ì§€ë©´ ê°™ì´ ë¶€ë“œëŸ½ê²Œ */
body.theme-desert {
  background: linear-gradient(
    to bottom,
    #a16207 0%,   /* ìœ„ â€“ ì§™ì€ ëª¨ë˜/ë°”ìœ„ìƒ‰ */
    #f97316 35%,  /* ì¤‘ê°„ â€“ ì£¼í™©ë¹› ëª¨ë˜ */
    #fdba74 70%,  /* ì•„ë˜ â€“ ë°ì€ ëª¨ë˜ìƒ‰ */
    #fef3c7 100%  /* ë§¨ ì•„ë˜ â€“ ì•„ì£¼ ì—°í•œ ëª¨ë˜ìƒ‰ */
  );
  background-repeat: no-repeat;
  background-attachment: fixed;
}

/* ğŸŒŒ ìš°ì£¼ í…Œë§ˆ: ê¸°ì¡´ ë³„ ìœ„ì— í° ë³„ ëª‡ ê°œ ì¶”ê°€ ë ˆì´ì–´ */
body.theme-space::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: -1;              /* ê²Œì„ í™”ë©´ ë’¤ìª½ì—ë§Œ ë³´ì´ê²Œ */
  opacity: 0.95;
  mix-blend-mode: screen;
  filter: brightness(1.6) drop-shadow(0 0 4px white);

  /* 7px / 6px / 5px ì •ë„ í¬ê¸°ì˜ ë³„ë“¤ì„ 1/3ì”© ë°°ì¹˜ */
  background-image:
    radial-gradient(7px 7px at 12% 12%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(6px 6px at 32% 20%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(5px 5px at 55% 18%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(7px 7px at 78% 22%, rgba(226, 232, 240, 1.0), transparent 60%),

    radial-gradient(6px 6px at 18% 45%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(5px 5px at 45% 40%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(7px 7px at 70% 48%, rgba(226, 232, 240, 1.0), transparent 60%),
    radial-gradient(6px 6px at 90% 42%, rgba(255, 255, 255, 1.0), transparent 60%),

    radial-gradient(5px 5px at 22% 72%, rgba(248, 250, 252, 1.0), transparent 60%),
    radial-gradient(7px 7px at 52% 78%, rgba(255, 255, 255, 1.0), transparent 60%),
    radial-gradient(6px 6px at 78% 74%, rgba(226, 232, 240, 1.0), transparent 60%);
}

</style>
</head>
<body class="theme-default">
  <h1>ì£¼ì‚¬ìœ„ ë³´ë“œê²Œì„</h1>
  <p style="text-align:center; font-size:12px; opacity:0.7; margin-top:-4px; margin-bottom:10px;">
    ë§Œë“  ì´: ì„œë¯¼ì¬
  </p>

  <div class="game-container">
    <div class="top-panel">
      <div class="status-block">
        <div class="status">
          í˜„ì¬ ì°¨ë¡€: <span id="currentPlayer"></span><br />
          ë§ ìœ„ì¹˜: <span id="positions"></span>
        </div>
        <div class="config">
          <label>
            ì¸ì› ìˆ˜:
            <select id="playerCount">
              <option value="1">1ëª…</option>
              <option value="2" selected>2ëª…</option>
              <option value="3">3ëª…</option>
              <option value="4">4ëª…</option>
              <option value="5">5ëª…</option>
              <option value="6">6ëª…</option>
            </select>
          </label>
           <label>
            ì „ì²´ ì¹¸ìˆ˜:
            <input type="number" id="boardSizeInput" min="6" max="200" value="30" />
          </label>
          <label>
            í…Œë§ˆ:
            <select id="themeSelect">
              <option value="default">ê¸°ë³¸</option>
              <option value="space">ìš°ì£¼</option>
              <option value="forest">ìˆ²</option>
              <option value="desert">ì‚¬ë§‰</option>
              <option value="neon">ë„¤ì˜¨</option>
            </select>
          </label>

          <button id="startBtn">ê²Œì„ ì‹œì‘ / ë¦¬ì…‹</button>
  <button id="soundToggleBtn" type="button">ğŸ”Š íš¨ê³¼ìŒ ì¼œì§</button>
        </div>
      </div>

      <div class="dice-box">
<div class="dice-row">
  <button id="rollBtn">ğŸ² ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°</button>
  <button id="skipBtn">â­ï¸ í„´ ìŠ¤í‚µ</button>
  <div class="dice-visual" id="diceVisual">-</div>
  <div class="cheat-badge">
    <span id="cheatText">ì¹˜íŠ¸: ì—†ìŒ</span>
  </div>

  <!-- ğŸ”½ ì¹˜íŠ¸ ì»¤ë§¨ë“œ ì…ë ¥ì°½ì„ ì—¬ê¸°ë¡œ ì´ë™ -->
  <label class="cheat-input">
    ì»¤ë§¨ë“œ:
    <input type="text" id="secretCodeInput" placeholder="ì¹˜íŠ¸ ì½”ë“œ" />
  </label>
</div>

        <div class="dice-value" id="diceInfo">
          ê²Œì„ì„ ì‹œì‘í•œ ë’¤ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ë³´ì„¸ìš”.
        </div>
      </div>
    </div>

    <div class="board" id="board"></div>

     <!-- ğŸ”½ ì¹¸ í¸ì§‘ ëª¨ë“œ ì¹´ë“œ (ì ‘ê¸°/í¼ì¹˜ê¸° ê°€ëŠ¥ ë²„ì „) -->
    <div class="cell-edit-card" id="cellEditCard">
      <div class="cell-edit-header">
        <div class="cell-edit-title">
          <span class="cell-edit-title-icon">ğŸ› </span>
          <span>ì¹¸ í¸ì§‘ ëª¨ë“œ</span>
        </div>

        <!-- ì ‘ê¸° / í¼ì¹˜ê¸° ë²„íŠ¼ -->
        <button type="button"
                class="cell-edit-toggle"
                id="cellEditToggleBtn">
          ì¹¸ í¸ì§‘ ì ‘ê¸° â–²
        </button>

        <div class="cell-edit-sub">
          ë²„íŠ¼ì„ ê³ ë¥¸ ë’¤, ìœ„ ë³´ë“œ ì¹¸ì„ í´ë¦­í•´ì„œ íŠ¹ìˆ˜ ì¹¸ìœ¼ë¡œ ì„¤ì •í•˜ì„¸ìš”.
        </div>
      </div>

      <!-- ì´ ì•ˆìª½ ë¶€ë¶„ ì „ì²´ê°€ ì ‘í˜”ë‹¤/í¼ì³ì§ -->
      <div class="cell-edit-body" id="cellEditBody">
        <div class="cell-edit-panel">
          <button type="button" class="cell-edit-btn active" data-mode="off">
            <span class="cell-edit-btn-icon">ğŸš«</span>
            <span>í¸ì§‘ ë”</span>
          </button>
          <button type="button" class="cell-edit-btn" data-mode="x2">
            <span class="cell-edit-btn-icon">ğŸš€</span>
            <span>x2</span>
          </button>
          <button type="button" class="cell-edit-btn" data-mode="half">
            <span class="cell-edit-btn-icon">ğŸ¢</span>
            <span>1/2</span>
          </button>
          <button type="button" class="cell-edit-btn" data-mode="trap">
            <span class="cell-edit-btn-icon">ğŸ’£</span>
            <span>í•¨ì •</span>
          </button>
          <button type="button" class="cell-edit-btn" data-mode="gkey">
            <span class="cell-edit-btn-icon">âœ¨</span>
            <span>í™©ê¸ˆì—´ì‡ </span>
          </button>
          <button type="button" class="cell-edit-btn" data-mode="clear">
            <span class="cell-edit-btn-icon">â›”</span>
            <span>ì§€ìš°ê¸°</span>
          </button>
        </div>

        <div class="cell-edit-hint">
          â€¢ ì¶œë°œ(0), ë„ì°© ì¹¸ì€ í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. <br />
          â€¢ ê°™ì€ ì¹¸ì— x2/1/2/í•¨ì •/í™©ê¸ˆì—´ì‡ ë¥¼ ê²¹ì³ì„œ ì„¤ì •í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”. <br />
          â€¢ ì•„ë˜ ì…ë ¥ì¹¸ì—ì„œ ìˆ«ìë¡œë„ ì§ì ‘ íŠ¹ìˆ˜ ì¹¸ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>

        <!-- ğŸ”§ x2 / 1/2 / í•¨ì • / í™©ê¸ˆì—´ì‡  ì¹¸ ë²”ìœ„ ì„¤ì • ì…ë ¥ -->
        <div class="cell-range-edit">
          <label>
            x2 ì¹¸:
            <input type="text" id="x2CellsInput" placeholder="ì˜ˆ: 2,5,9 ë˜ëŠ” 2~4" />
          </label>
          <label>
            1/2 ì¹¸:
            <input type="text" id="halfCellsInput" placeholder="ì˜ˆ: 4,6 ë˜ëŠ” 7~9" />
          </label>
          <label>
            í•¨ì • ì¹¸(ì¶œë°œë¡œ):
            <input type="text" id="resetCellsInput" placeholder="ì˜ˆ: 1,3,5 ë˜ëŠ” 10~12" />
          </label>
          <label>
            í™©ê¸ˆì—´ì‡  ì¹¸:
            <input type="text" id="gKeyCellsInput" placeholder="ì˜ˆ: 2,7 ë˜ëŠ” 10~12" />
          </label>
        </div>
      </div>
    </div>
    <!-- ğŸ”¼ ì¹¸ í¸ì§‘ ëª¨ë“œ ì¹´ë“œ ë -->


    <div class="players-legend" id="playersLegend"></div>

    <div class="log-box" id="log"></div>
  </div>

  <div id="goldenKeyOverlay">
    <div id="goldenKeyPopup">
      <span>ğŸ”‘</span>
      <span>í™©ê¸ˆì—´ì‡ !</span>
    </div>
    <div id="cheatPopup">
      <span id="cheatPopupIcon">âœ¨</span>
      <span id="cheatPopupText">ì¹˜íŠ¸ ë°œë™!</span>
    </div>
  </div>

  <!-- ğŸµ íš¨ê³¼ìŒ -->
  <audio id="seClick"  src="game/click.mp3"  preload="auto"></audio>
  <audio id="seDice"   src="game/dice.mp3"   preload="auto"></audio>
  <audio id="seTrap"   src="game/trap.mp3"   preload="auto"></audio>
  <audio id="seGolden" src="game/golden.mp3" preload="auto"></audio>
  <audio id="seCheat"  src="game/cheat.mp3"  preload="auto"></audio>
  <audio id="seWin"    src="game/win.mp3"    preload="auto"></audio>
  <audio id="seShield" src="game/shield.mp3" preload="auto"></audio>
  <audio id="seSpeed"  src="game/speed.mp3"  preload="auto"></audio>
  <audio id="seSpeedHalf" src="game/speed_half.mp3" preload="auto"></audio>

  <script>
    let BOARD_SIZE = 30;
    let specialZones = [];
    let resetCells = [];
    let goldenKeyCells = [];
    let cellEditMode = "off";

    const PLAYER_COLORS = [
      "#ef4444",
      "#3b82f6",
      "#22c55e",
      "#f97316",
      "#a855f7",
      "#eab308"
    ];

    const CHEAT_DEFS = [
      { code: "3025", name: "í™©ê¸ˆ 15", desc: "ì£¼ì‚¬ìœ„ ëˆˆì„ 15ë¡œ ê³ ì •" },
      { code: "1357", name: "ì´ë™ 2ë°°", desc: "ì´ë™ ê±°ë¦¬ 2ë°°" },
      { code: "2468", name: "í•¨ì • ì˜êµ¬ ë¬´ì‹œ", desc: "ë‚¨ì€ ê²Œì„ ë™ì•ˆ í•¨ì • ì¹¸ ë¬´ì‹œ" },
      { code: "4444", name: "2íšŒ ë³´í˜¸ë§‰", desc: "í•´ë¡œìš´ íš¨ê³¼ 2ë²ˆ ë°©ì–´" },
      { code: "9999", name: "ì¶”ê°€ í„´", desc: "ì´ë™ í›„ í•œ ë²ˆ ë” í„´" },
      { code: "1111", name: "ì„ ë‘ ë°”ë¡œ ë’¤ ì›Œí”„", desc: "ì„ ë‘ ë°”ë¡œ ë’¤ ì¹¸ìœ¼ë¡œ ì´ë™" },
      { code: "2222", name: "ì„ ë‘ì™€ êµí™˜", desc: "ì„ ë‘ì™€ ìœ„ì¹˜ ë°”ê¾¸ê¸°" },
      { code: "3333", name: "ë‹¤ë¥¸ ì‚¬ëŒ -1ì¹¸", desc: "ë‚˜ ë¹¼ê³  ëª¨ë‘ 1ì¹¸ ë’¤ë¡œ" },
      { code: "5555", name: "ì¬êµ´ë¦¼(í° ìˆ˜)", desc: "ë‘ ë²ˆ êµ´ë ¤ ë” í° ìˆ˜ ì‚¬ìš©" },
      { code: "6666", name: "ì„ ë‘ ì›Œí”„+í„´ ìŠ¤í‚µ", desc: "ì„ ë‘ ìœ„ì¹˜ë¡œ ì´ë™, ë‹¤ìŒ ìê¸° í„´ ìŠ¤í‚µ" },
      { code: "7777", name: "Â±3 ëœë¤", desc: "+3 ë˜ëŠ” -3 ëœë¤ ì´ë™" },
      { code: "8888", name: "ì¤‘ì•™ ì›Œí”„", desc: "ë³´ë“œ ì¤‘ì•™ìœ¼ë¡œ ì´ë™" }
    ];

    let players = [];
    let currentPlayerIndex = 0;
    let gameOver = false;
    let isAnimating = false;
    let isRollingDice = false;

    const cellTokenEls = [];

    const boardEl = document.getElementById("board");
    const gameContainerEl = document.querySelector(".game-container");
    const rollBtn = document.getElementById("rollBtn");
    const skipBtn = document.getElementById("skipBtn");
    const diceInfoEl = document.getElementById("diceInfo");
    const diceVisualEl = document.getElementById("diceVisual");
    const currentPlayerEl = document.getElementById("currentPlayer");
    const positionsEl = document.getElementById("positions");
    const logEl = document.getElementById("log");
    const playersLegendEl = document.getElementById("playersLegend");
    const playerCountSelect = document.getElementById("playerCount");
    const startBtn = document.getElementById("startBtn");
    const boardSizeInput = document.getElementById("boardSizeInput");
    const x2CellsInput = document.getElementById("x2CellsInput");
    const halfCellsInput = document.getElementById("halfCellsInput");
    const resetCellsInput = document.getElementById("resetCellsInput");
    const gKeyCellsInput = document.getElementById("gKeyCellsInput");
    const secretCodeInput = document.getElementById("secretCodeInput");
    const boostRangeText = document.getElementById("boostRangeText");
    const slowRangeText = document.getElementById("slowRangeText");
    const resetRangeText = document.getElementById("resetRangeText");
    const gKeyRangeText = document.getElementById("gKeyRangeText");
    const cheatTextEl = document.getElementById("cheatText");
    const goldenKeyOverlayEl = document.getElementById("goldenKeyOverlay");
    const goldenKeyPopupEl = document.getElementById("goldenKeyPopup");
    const cheatPopupEl = document.getElementById("cheatPopup");
    const cheatPopupTextEl = document.getElementById("cheatPopupText");
    const cheatPopupIconEl = document.getElementById("cheatPopupIcon");
    const themeSelect = document.getElementById("themeSelect");
    const cellEditButtons = document.querySelectorAll(".cell-edit-btn");
    const cellEditCardEl = document.getElementById("cellEditCard");
    const soundToggleBtn = document.getElementById("soundToggleBtn");
    const cellEditBodyEl = document.getElementById("cellEditBody");
    const cellEditToggleBtn = document.getElementById("cellEditToggleBtn");

    const THEME_CLASS_LIST = [
      "theme-default",
      "theme-space",
      "theme-forest",
      "theme-desert",
      "theme-neon"
    ];

    function applyTheme(themeName) {
      const body = document.body;
      THEME_CLASS_LIST.forEach((cls) => body.classList.remove(cls));
      body.classList.add("theme-" + themeName);
    }

    // ğŸµ íš¨ê³¼ìŒ ë§¤í•‘
    const soundMap = {
      click:  document.getElementById("seClick"),
      dice:   document.getElementById("seDice"),
      trap:   document.getElementById("seTrap"),
      golden: document.getElementById("seGolden"),
      cheat:  document.getElementById("seCheat"),
      win:    document.getElementById("seWin"),
      shield: document.getElementById("seShield"),
      speed:  document.getElementById("seSpeed"),
      speedHalf: document.getElementById("seSpeedHalf")
    };

    function playSound(name) {
      // ğŸ”‡ íš¨ê³¼ìŒì´ êº¼ì ¸ ìˆìœ¼ë©´ ì•„ë¬´ ì†Œë¦¬ë„ ì¬ìƒí•˜ì§€ ì•ŠìŒ
      if (!isSoundOn) return;

      const audio = soundMap[name];
      if (!audio) return;
      try {
        audio.currentTime = 0;
        audio.play();
      } catch (e) {}
    }


    let popupTimerId = null;
    let isSoundOn = true; // íš¨ê³¼ìŒ ì¼œì§/êº¼ì§ ìƒíƒœ

    // â­ HEX â†’ rgba ë³€í™˜ (ë„¤ì˜¨ ê·¸ë¼ë°ì´ì…˜ìš©)
    function hexToRgba(hex, alpha) {
      if (!hex) return "";
      let h = hex.trim();
      if (h[0] === "#") h = h.slice(1);
      if (h.length === 3) {
        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
      }
      if (h.length !== 6) return hex;
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      if ([r, g, b].some(v => Number.isNaN(v))) return hex;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function setDiceFace(value) {
      diceVisualEl.innerHTML = "";

      if (value >= 1 && value <= 6) {
        const pipMap = {
          1: [4],
          2: [0, 8],
          3: [0, 4, 8],
          4: [0, 2, 6, 8],
          5: [0, 2, 4, 6, 8],
          6: [0, 2, 3, 5, 6, 8]
        };
        const positions = pipMap[value] || [];

        const grid = document.createElement("div");
        grid.className = "dice-pip-grid";

        for (let i = 0; i < 9; i++) {
          const cell = document.createElement("div");
          cell.className = "dice-cell";
          if (positions.includes(i)) {
            const pip = document.createElement("div");
            pip.className = "dice-pip";
            cell.appendChild(pip);
          }
          grid.appendChild(cell);
        }

        diceVisualEl.appendChild(grid);
      } else {
        diceVisualEl.textContent = String(value);
      }
    }

    function log(message) {
      const div = document.createElement("div");
      div.className = "log-entry";
      div.textContent = message;
      logEl.prepend(div);
    }

    function findZone(pos) {
      return specialZones.find((z) => pos >= z.start && pos <= z.end) || null;
    }

    function getMultiplierInfo(pos) {
      const zone = findZone(pos);
      if (!zone) return { multiplier: 1, label: "ì¼ë°˜ êµ¬ê°„" };
      return {
        multiplier: zone.multiplier,
        label:
          zone.multiplier > 1
            ? `${zone.multiplier}ë°° ì†ë„ êµ¬ê°„`
            : `${zone.multiplier}ë°° ëŠë ¤ì§€ëŠ” êµ¬ê°„`
      };
    }

    function resetDiceStyle() {
      diceVisualEl.classList.remove("cheat-active");
      diceVisualEl.style.borderColor = "";
      diceVisualEl.style.background = "";
      diceVisualEl.style.color = "";
      diceVisualEl.style.boxShadow = "";
    }

    // âœ… ë³€ê²½: í”Œë ˆì´ì–´ ë§ ìƒ‰ ê¸°ë°˜ ë„¤ì˜¨ì„ ì¢€ ë” ì—°í•˜ê²Œ í‘œí˜„
    function setDiceNeonForColor(color) {
      if (!color) {
        resetDiceStyle();
        return;
      }
      const softOuter = hexToRgba(color, 0.25); // ë°”ê¹¥ìª½ ì€ì€í•œ ìƒ‰
      const softInner = hexToRgba(color, 0.10); // ì•ˆìª½ ë” ì—°í•œ ìƒ‰

      diceVisualEl.style.borderColor = softOuter;
      diceVisualEl.style.background =
        `radial-gradient(circle at 30% 20%, #ffffff 0%, ${softInner} 50%, ${softOuter} 100%)`;
      diceVisualEl.style.color = "#111827";
      diceVisualEl.style.boxShadow = `0 0 10px ${softOuter}`;
    }

    function parseCellList(raw, boardSize) {
      const result = [];
      if (!raw || raw.trim().length === 0) return result;

      const tokens = raw
        .split(/[,\s]+/)
        .map((t) => t.trim())
        .filter(Boolean);

      tokens.forEach((token) => {
        const rangeMatch = token.match(/^(\d+)\s*~\s*(\d+)$/);
        if (rangeMatch) {
          let a = parseInt(rangeMatch[1], 10);
          let b = parseInt(rangeMatch[2], 10);
          if (isNaN(a) || isNaN(b)) return;
          if (a > b) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          for (let n = a; n <= b; n++) {
            if (n > 0 && n < boardSize - 1) result.push(n);
          }
          return;
        }

        const n = parseInt(token, 10);
        if (!isNaN(n) && n > 0 && n < boardSize - 1) {
          result.push(n);
        }
      });

      return Array.from(new Set(result)).sort((a, b) => a - b);
    }

    function getCheatsForCurrentRoll() {
      const cheats = {
        goldenTen: false,
        doubleStep: false,
        trapImmune: false,
        extraTurn: false,
        leadFollow: false,
        swapLead: false,
        warpLeadSkip: false,
        pushOthersBack: false,
        shield2turn: false,
        rerollHigher: false,
        randomPlusMinus3: false,
        warpMiddle: false,
        triggered: []
      };

      const currentPlayer = players[currentPlayerIndex];

      let rawCodes = [];
      const raw = secretCodeInput.value;
      if (raw && raw.trim().length > 0) {
        rawCodes = raw.split(/[,\s]+/).map(c => c.trim()).filter(Boolean);
      }

      if (currentPlayer && currentPlayer.storedCheatCode) {
        rawCodes.push(currentPlayer.storedCheatCode);
        currentPlayer.storedCheatCode = null;
      }

      if (rawCodes.length === 0) return cheats;

      const codes = Array.from(new Set(rawCodes));
      let hasUnknown = false;

      codes.forEach((code) => {
        const def = CHEAT_DEFS.find(d => d.code === code);
        if (!def) {
          hasUnknown = true;
          return;
        }

        cheats.triggered.push(def);

        if (code === "3025")      cheats.goldenTen = true;
        else if (code === "1357") cheats.doubleStep = true;
        else if (code === "2468") cheats.trapImmune = true;
        else if (code === "9999") cheats.extraTurn = true;
        else if (code === "1111") cheats.leadFollow = true;
        else if (code === "2222") cheats.swapLead = true;
        else if (code === "6666") cheats.warpLeadSkip = true;
        else if (code === "3333") cheats.pushOthersBack = true;
        else if (code === "4444") cheats.shield2turn = true;
        else if (code === "5555") cheats.rerollHigher = true;
        else if (code === "7777") cheats.randomPlusMinus3 = true;
        else if (code === "8888") cheats.warpMiddle = true;
      });

      if (hasUnknown) {
        log("â“ ì•Œ ìˆ˜ ì—†ëŠ” ì½”ë“œê°€ ìˆì–´ ë¬´ì‹œë˜ì—ˆìŠµë‹ˆë‹¤.");
      }

if (cheats.triggered.length > 0) {
  const txt = cheats.triggered
    .map(d => d.name)
    .join(", ");
  log(`âœ¨ ì¹˜íŠ¸ ë°œë™: ${txt}`);
}


      return cheats;
    }

    function spawnSparkles(baseColor) {
      const color = baseColor || "#facc15";
      const oldSparkles = goldenKeyOverlayEl.querySelectorAll(".sparkle");
      oldSparkles.forEach((el) => el.remove());

      const SPARKLE_COUNT = 90;
      for (let i = 0; i < SPARKLE_COUNT; i++) {
        const s = document.createElement("div");
        s.className = "sparkle";

        const topPercent = Math.random() * 100;
        const leftPercent = Math.random() * 100;
        const scale = 0.3 + Math.random() * 2.0;
        const delay = Math.random() * 0.7;
        const duration = 0.8 + Math.random() * 1.0;

        s.style.top = topPercent + "%";
        s.style.left = leftPercent + "%";
        s.style.transform = `scale(${scale})`;
        s.style.animationDelay = `${delay}s`;
        s.style.animationDuration = `${duration}s`;
        s.style.background = `radial-gradient(circle, #fefce8 0%, ${color} 40%, transparent 70%)`;
        s.style.boxShadow = `0 0 14px ${color}cc`;

        goldenKeyOverlayEl.appendChild(s);
      }
    }

    function showCheatPopup(style, labelText, prefixLabel = "ì¹˜íŠ¸", icon = "âœ¨", durationMs = 2000) {
      if (prefixLabel === "ì¹˜íŠ¸")         playSound("cheat");
      else if (prefixLabel === "í•¨ì •")    playSound("trap");
      else if (prefixLabel === "ë°©ì–´")    playSound("shield");
      else if (prefixLabel === "x2 ë°°ì†") playSound("speed");
      else if (prefixLabel === "1/2 ë°°ì†") playSound("speedHalf");

      goldenKeyOverlayEl.classList.remove("show");
      goldenKeyPopupEl.classList.remove("show");
      cheatPopupEl.classList.remove("show");

      if (popupTimerId !== null) {
        clearTimeout(popupTimerId);
        popupTimerId = null;
      }

      const color = style && style.color ? style.color : "#f97316";
      const bg = style && style.bg ? style.bg : "#fff7ed";

      cheatPopupEl.style.background = bg;
      cheatPopupEl.style.color = color;

      const popupSeconds = durationMs / 1000;
      cheatPopupEl.style.animationDuration = popupSeconds + "s";
      goldenKeyOverlayEl.style.animationDuration = popupSeconds + "s";

      cheatPopupIconEl.textContent = icon;

      if (labelText && labelText.length > 0) {
        if (prefixLabel) {
          cheatPopupTextEl.textContent = `${prefixLabel}: ${labelText}`;
        } else {
          cheatPopupTextEl.textContent = labelText;
        }
      } else {
        cheatPopupTextEl.textContent = prefixLabel ? `${prefixLabel}: íš¨ê³¼ ë°œë™!` : "íš¨ê³¼ ë°œë™!";
      }

      void goldenKeyOverlayEl.offsetWidth;

      goldenKeyOverlayEl.classList.add("show");
      spawnSparkles(color);
      cheatPopupEl.classList.add("show");

      popupTimerId = setTimeout(() => {
        goldenKeyOverlayEl.classList.remove("show");
        cheatPopupEl.classList.remove("show");
        const remain = goldenKeyOverlayEl.querySelectorAll(".sparkle");
        remain.forEach((el) => el.remove());
        popupTimerId = null;
      }, durationMs);
    }

    // â­ ì¹˜íŠ¸ í…ìŠ¤íŠ¸ + ì£¼ì‚¬ìœ„ ìƒ‰/ë„¤ì˜¨ ë™ê¸°í™”
    function showCheatText(cheats) {
      let firedText = null;
      if (cheats.triggered && cheats.triggered.length > 0) {
        firedText = cheats.triggered
          .map(d => `${d.name} ë°œë™`)
          .join(" / ");
        cheatTextEl.textContent = "ì¹˜íŠ¸: " + firedText;
      } else {
        cheatTextEl.textContent = "ì¹˜íŠ¸: ì—†ìŒ";
      }

      diceVisualEl.classList.remove("cheat-active");

      const styleMap = {
        goldenTen:       { color: "#f59e0b", bg: "#fffbeb", border: "#fbbf24" },
        doubleStep:      { color: "#3b82f6", bg: "#eff6ff", border: "#bfdbfe" },
        trapImmune:      { color: "#22c55e", bg: "#ecfdf3", border: "#bbf7d0" },
        extraTurn:       { color: "#a855f7", bg: "#faf5ff", border: "#e9d5ff" },
        leadFollow:      { color: "#ec4899", bg: "#fdf2f8", border: "#f9a8d4" },
        swapLead:        { color: "#06b6d4", bg: "#ecfeff", border: "#a5f3fc" },
        warpLeadSkip:    { color: "#0f766e", bg: "#ecfdf5", border: "#5eead4" },
        pushOthersBack:  { color: "#f97316", bg: "#fff7ed", border: "#fed7aa" },
        shield2turn:     { color: "#4f46e5", bg: "#eef2ff", border: "#c7d2fe" },
        rerollHigher:    { color: "#10b981", bg: "#ecfdf5", border: "#6ee7b7" },
        randomPlusMinus3:{ color: "#ef4444", bg: "#fef2f2", border: "#fecaca" },
        warpMiddle:      { color: "#8b5cf6", bg: "#f5f3ff", border: "#ddd6fe" }
      };

      const priority = [
        "goldenTen",
        "doubleStep",
        "trapImmune",
        "extraTurn",
        "leadFollow",
        "swapLead",
        "warpLeadSkip",
        "pushOthersBack",
        "shield2turn",
        "rerollHigher",
        "randomPlusMinus3",
        "warpMiddle"
      ];

      let mainKey = null;
      for (const k of priority) {
        if (cheats[k]) {
          mainKey = k;
          break;
        }
      }

      if (!mainKey) {
        resetDiceStyle();
        cheatTextEl.style.color = "#4b5563";
        return;
      }

      const s = styleMap[mainKey];
      if (s) {
        const softGlow = hexToRgba(s.color, 0.6);
        diceVisualEl.style.borderColor = s.border;
        diceVisualEl.style.background = s.bg;
        diceVisualEl.style.color = s.color;
        diceVisualEl.style.boxShadow =
          `0 0 20px ${s.color}, 0 0 40px ${softGlow}`;
        cheatTextEl.style.color = s.color;
        diceVisualEl.classList.add("cheat-active");

        showCheatPopup(s, firedText, "ì¹˜íŠ¸", "âœ¨", 2000);
      } else {
        resetDiceStyle();
        cheatTextEl.style.color = "#4b5563";
      }
    }

    function updateStatusText() {
      if (players.length === 0) {
        currentPlayerEl.textContent = "-";
        currentPlayerEl.style.color = "#111827";
        positionsEl.textContent = "-";
        return;
      }

      const current = players[currentPlayerIndex];
      currentPlayerEl.textContent = current.name;
      currentPlayerEl.style.color = current.color;

      const posText = players
        .map((p) => `${p.name}: ${p.position}ì¹¸`)
        .join(" / ");
      positionsEl.textContent = posText;

      const pills = playersLegendEl.querySelectorAll(".player-pill");
      pills.forEach((pill, idx) => {
        pill.classList.toggle("current-turn", idx === currentPlayerIndex);
      });
    }

    function renderPlayersLegend() {
      playersLegendEl.innerHTML = "";
      players.forEach((p, idx) => {
        const pill = document.createElement("div");
        pill.className = "player-pill";
        pill.innerHTML = `
          <span class="player-dot" style="background:${p.color}"></span>
          <span>${p.name}</span>
        `;
        if (idx === currentPlayerIndex) {
          pill.classList.add("current-turn");
        }
        playersLegendEl.appendChild(pill);
      });
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      cellTokenEls.length = 0;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";

        const zone = findZone(i);
        const isReset = resetCells.includes(i);
        const isGKey = goldenKeyCells.includes(i);

        if (zone) {
          if (zone.multiplier > 1) cell.classList.add("zone-boost");
          else if (zone.multiplier < 1) cell.classList.add("zone-slow");
        }
        if (isReset) cell.classList.add("zone-reset");
        if (isGKey) cell.classList.add("zone-gkey");

        let indexLabel = `${i}`;
        if (i === 0) {
          indexLabel = "ğŸš© ì¶œë°œ(0)";
          cell.classList.add("start-cell");
        } else if (i === BOARD_SIZE - 1) {
          indexLabel = `ğŸ ë„ì°©(${i})`;
          cell.classList.add("finish-cell");
        }

        const labels = [];
        if (zone && zone.multiplier !== 1) labels.push(`${zone.multiplier}ë°°`);
        if (isReset) labels.push("í•¨ì •");
        if (isGKey) labels.push("í™©ê¸ˆì—´ì‡ ");

        const labelText = labels.join(" / ");

        cell.innerHTML = `
          <div class="cell-index">${indexLabel}</div>
          <div class="cell-zone-label">${labelText}</div>
          <div class="token-container"></div>
        `;

        // ë³´ë“œ ì¹¸ í´ë¦­ ì‹œ í¸ì§‘ ëª¨ë“œ ë™ì‘
        cell.addEventListener("click", () => {
          handleCellClick(i);
        });

        boardEl.appendChild(cell);
        const tokenContainer = cell.querySelector(".token-container");
        cellTokenEls.push(tokenContainer);
      }
    }

    function renderTokens() {
      cellTokenEls.forEach((el) => (el.innerHTML = ""));

      players.forEach((p, idx) => {
        const pos = p.position;
        if (pos < 0 || pos >= BOARD_SIZE) return;
        const container = cellTokenEls[pos];
        if (!container) return;

        const token = document.createElement("div");
        token.className = "token";
        token.style.background = p.color;
        token.title = p.name;

        if (idx === currentPlayerIndex) {
          token.classList.add("current-turn");
        }

        if (p.isFastMoving) {
          token.classList.add("token-fast");
        }

        container.appendChild(token);
      });
    }

    function cellsToText(arr) {
      if (!arr || arr.length === 0) return "ì—†ìŒ";
      return arr.join(", ") + "ë²ˆ ì¹¸";
    }

   function updateLegendText() {
  // âš  ë²”ë¡€ í‘œì‹œìš© DOM ìš”ì†Œ(í…ìŠ¤íŠ¸)ê°€ í˜„ì¬ í™”ë©´ì— ì—†ìœ¼ë¯€ë¡œ
  //    ì—†ìœ¼ë©´ ê·¸ëƒ¥ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•Šê³  ë¹ ì ¸ë‚˜ì˜¤ë„ë¡ ì˜ˆì™¸ ì²˜ë¦¬
  if (!boostRangeText || !slowRangeText || !resetRangeText || !gKeyRangeText) {
    return;
  }

  const boostCells = [];
  const slowCells = [];

  for (let i = 0; i < BOARD_SIZE; i++) {
    const zone = findZone(i);
    if (!zone) continue;
    if (zone.multiplier > 1) boostCells.push(i);
    else if (zone.multiplier < 1) slowCells.push(i);
  }

  boostRangeText.textContent = cellsToText(boostCells);
  slowRangeText.textContent = cellsToText(slowCells);
  resetRangeText.textContent = resetCells.length
    ? resetCells.join(", ") + "ë²ˆ ì¹¸"
    : "ì—†ìŒ";
  gKeyRangeText.textContent = goldenKeyCells.length
    ? goldenKeyCells.join(", ") + "ë²ˆ ì¹¸"
    : "ì—†ìŒ";
}

    function setCellMultiplierSingle(index, multiplier) {
      // í•´ë‹¹ ì¹¸ì˜ ë°°ì† ì •ë³´ë¥¼ ë‹¨ì¼ ì¹¸ ê¸°ì¤€ìœ¼ë¡œ ê´€ë¦¬
      specialZones = specialZones.filter((z) => !(z.start === index && z.end === index));
      if (multiplier === 1) return;
      const label = multiplier > 1 ? "x2 ì¹¸" : "1/2 ì¹¸";
      specialZones.push({ start: index, end: index, multiplier, label });
    }

    function toggleValueInArray(arr, value) {
      const idx = arr.indexOf(value);
      if (idx >= 0) {
        arr.splice(idx, 1);
        return false;
      } else {
        arr.push(value);
        arr.sort((a, b) => a - b);
        return true;
      }
    }

    function syncInputsFromState() {
      const x2Arr = [];
      const halfArr = [];
      specialZones.forEach((z) => {
        if (z.start === z.end) {
          if (z.multiplier > 1) x2Arr.push(z.start);
          else if (z.multiplier < 1) halfArr.push(z.start);
        }
      });

      const uniqSorted = (arr) => Array.from(new Set(arr)).sort((a, b) => a - b);

      if (typeof x2CellsInput !== "undefined" && x2CellsInput) {
        x2CellsInput.value = uniqSorted(x2Arr).join(", ");
      }
      if (typeof halfCellsInput !== "undefined" && halfCellsInput) {
        halfCellsInput.value = uniqSorted(halfArr).join(", ");
      }
      if (typeof resetCellsInput !== "undefined" && resetCellsInput) {
        resetCellsInput.value = uniqSorted(resetCells).join(", ");
      }
      if (typeof gKeyCellsInput !== "undefined" && gKeyCellsInput) {
        gKeyCellsInput.value = uniqSorted(goldenKeyCells).join(", ");
      }

      updateLegendText();
    }

        function handleCellClick(index) {
      // í¸ì§‘ ëª¨ë“œê°€ ì•„ë‹ˆë©´ ì•„ë¬´ ì¼ë„ í•˜ì§€ ì•ŠìŒ
      if (cellEditMode === "off") return;
      // ì¶œë°œ(0), ë„ì°©(BOARD_SIZE-1)ì€ í¸ì§‘ ë¶ˆê°€
      if (index <= 0 || index >= BOARD_SIZE - 1) return;

      // í˜„ì¬ ë³´ë“œ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ì…ë ¥ê°’ì„ ë‹¤ì‹œ í•´ì„
      let sizeVal = parseInt(boardSizeInput.value, 10);
      if (isNaN(sizeVal) || sizeVal < 6) sizeVal = 30;
      const boardSize = Math.max(6, Math.min(sizeVal, 200));

      const x2Arr = parseCellList(x2CellsInput.value, boardSize);
      const halfArr = parseCellList(halfCellsInput.value, boardSize);
      const trapArr = parseCellList(resetCellsInput.value, boardSize);
      const gkeyArr = parseCellList(gKeyCellsInput.value, boardSize);

      const x2Set = new Set(x2Arr);
      const halfSet = new Set(halfArr);
      const trapSet = new Set(trapArr);
      const gkeySet = new Set(gkeyArr);

      let changed = false;

      if (cellEditMode === "x2") {
        if (x2Set.has(index)) {
          x2Set.delete(index);
        } else {
          x2Set.add(index);
        }
        // x2ì™€ 1/2ëŠ” ë™ì‹œì— ìˆì„ ìˆ˜ ì—†ë„ë¡ 1/2 ìª½ì—ì„œ ì œê±°
        halfSet.delete(index);
        changed = true;
      } else if (cellEditMode === "half") {
        if (halfSet.has(index)) {
          halfSet.delete(index);
        } else {
          halfSet.add(index);
        }
        // 1/2ë¥¼ ì„¤ì •í•˜ë©´ x2ëŠ” ì œê±°
        x2Set.delete(index);
        changed = true;
      } else if (cellEditMode === "trap") {
        if (trapSet.has(index)) {
          trapSet.delete(index);
        } else {
          trapSet.add(index);
        }
        changed = true;
      } else if (cellEditMode === "gkey") {
        if (gkeySet.has(index)) {
          gkeySet.delete(index);
        } else {
          gkeySet.add(index);
        }
        changed = true;
      } else if (cellEditMode === "clear") {
        const before =
          x2Set.size + halfSet.size + trapSet.size + gkeySet.size;
        x2Set.delete(index);
        halfSet.delete(index);
        trapSet.delete(index);
        gkeySet.delete(index);
        const after =
          x2Set.size + halfSet.size + trapSet.size + gkeySet.size;
        changed = before !== after;
      }

      if (!changed) return;

      const sortArr = (set) => Array.from(set).sort((a, b) => a - b);

      const x2New = sortArr(x2Set);
      const halfNew = sortArr(halfSet);
      const trapNew = sortArr(trapSet);
      const gkeyNew = sortArr(gkeySet);

      // ì…ë ¥ì°½ ë¬¸ìì—´ ê°±ì‹ 
      x2CellsInput.value = x2New.join(", ");
      halfCellsInput.value = halfNew.join(", ");
      resetCellsInput.value = trapNew.join(", ");
      gKeyCellsInput.value = gkeyNew.join(", ");

      // ì‹¤ì œ ê²Œì„ ìƒíƒœ(specialZones, resetCells, goldenKeyCells)ë„ ë‹¤ì‹œ êµ¬ì„±
      specialZones = [];
      x2New.forEach((n) => {
        specialZones.push({ start: n, end: n, multiplier: 2, label: "x2 ì¹¸" });
      });
      halfNew.forEach((n) => {
        specialZones.push({ start: n, end: n, multiplier: 0.5, label: "1/2 ì¹¸" });
      });
      resetCells = trapNew;
      goldenKeyCells = gkeyNew;

      // ë³´ë“œ/ë§ ë° ë²”ë¡€ ê°±ì‹ 
      renderBoard();
      renderTokens();
      updateLegendText();
    }



    function animateMove(player, steps, onComplete) {
      if (steps <= 0) {
        onComplete();
        return;
      }
      isAnimating = true;
      let moved = 0;

      function step() {
        if (moved >= steps) {
          isAnimating = false;

          const landingCell = boardEl.children[player.position];
          if (landingCell) {
            landingCell.classList.add("landing");
            setTimeout(() => {
              landingCell.classList.remove("landing");
            }, 350);
          }

          onComplete();
          return;
        }

        let newPos = player.position + 1;
        const finishPos = BOARD_SIZE - 1;
        if (newPos >= finishPos) newPos = finishPos;

        player.position = newPos;
        renderTokens();
        updateStatusText();
        moved++;

        if (player.position === finishPos || moved >= steps) {
          isAnimating = false;

          const landingCell = boardEl.children[player.position];
          if (landingCell) {
            landingCell.classList.add("landing");
            setTimeout(() => {
              landingCell.classList.remove("landing");
            }, 350);
          }

          onComplete();
          return;
        }

        setTimeout(step, 250);
      }

      step();
    }

    function showGoldenKeyPopup() {
      playSound("golden");

      goldenKeyOverlayEl.classList.remove("show");
      goldenKeyPopupEl.classList.remove("show");
      cheatPopupEl.classList.remove("show");

      if (popupTimerId !== null) {
        clearTimeout(popupTimerId);
        popupTimerId = null;
      }

      const durationMs = 2000;
      const seconds = durationMs / 1000;
      goldenKeyPopupEl.style.animationDuration = seconds + "s";
      goldenKeyOverlayEl.style.animationDuration = seconds + "s";

      void goldenKeyOverlayEl.offsetWidth;

      goldenKeyOverlayEl.classList.add("show");
      spawnSparkles("#facc15");
      goldenKeyPopupEl.classList.add("show");

      popupTimerId = setTimeout(() => {
        goldenKeyOverlayEl.classList.remove("show");
        goldenKeyPopupEl.classList.remove("show");
        const remain = goldenKeyOverlayEl.querySelectorAll(".sparkle");
        remain.forEach((el) => el.remove());
        popupTimerId = null;
      }, durationMs);
    }

    function grantRandomCheatFromGoldenKey(player) {
      if (!CHEAT_DEFS.length) return;
      const idx = Math.floor(Math.random() * CHEAT_DEFS.length);
      const picked = CHEAT_DEFS[idx];

      player.storedCheatCode = picked.code;

const msg =
  `ğŸ”‘ í™©ê¸ˆì—´ì‡ ! ë‹¤ìŒ í„´ì— íŠ¹ìˆ˜í•œ íš¨ê³¼ê°€ ì ìš©ë©ë‹ˆë‹¤. ` +
  `(ë‹¤ìŒ ${player.name}ì˜ ìê¸° í„´ì— 1íšŒ ìë™ ì ìš©)`;
log(msg);


      diceInfoEl.textContent = "í™©ê¸ˆì—´ì‡ : ë‹¤ìŒ í„´ì— íŠ¹ìˆ˜í•œ íš¨ê³¼ê°€ ì ìš©ë©ë‹ˆë‹¤.";

      showGoldenKeyPopup();
    }

    function useShield(player, context) {
      if (!player.shieldChargesRemaining || player.shieldChargesRemaining <= 0) return false;
      player.shieldChargesRemaining--;
      const usedCount = 2 - player.shieldChargesRemaining;
      const usedText = ` (2íšŒì¤‘ ${usedCount}ë²ˆ ì‚¬ìš©)`;

      let msg;
      switch (context) {
        case "trap":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) í•¨ì •ìœ¼ë¡œ ì¸í•œ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "swap":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) ìë¦¬ êµí™˜ìœ¼ë¡œ ì¸í•œ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "pushBack":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) ë’¤ë¡œ ë°€ë¦¬ëŠ” í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "minus3":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) -3ì¹¸ ì´ë™ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        default:
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
      }
      log(msg);

      const popupLabel = `í•´ë¡œìš´ íš¨ê³¼ê°€ ë¬´íš¨í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (2íšŒì¤‘ ${usedCount}ë²ˆ ì‚¬ìš©)`;
      showCheatPopup(
        { color: "#bbf7d0", bg: "#064e3b" },
        popupLabel,
        "ë°©ì–´",
        "ğŸ›¡",
        2000
      );

      return true;
    }

    function afterMoveCheck(player, cheats) {
      renderTokens();
      updateStatusText();

      const finishPos = BOARD_SIZE - 1;

      if (player.position === finishPos) {
        playSound("win");
        log(`ğŸ‰ ${player.name}ì´(ê°€) ë„ì°© ì§€ì ì— ë¨¼ì € ë„ë‹¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ ì¢…ë£Œ!`);
        diceInfoEl.textContent = `${player.name} ìŠ¹ë¦¬! ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.`;
        gameOver = true;
        rollBtn.disabled = true;
        skipBtn.disabled = true;
        isRollingDice = false;
        isAnimating = false;
        return;
      }

      if (cheats.trapImmune) {
        player.trapImmune = true;
        log(`ğŸ§² ì¹˜íŠ¸: ${player.name}ì´(ê°€) ë‚¨ì€ ê²Œì„ ë™ì•ˆ í•¨ì • ì¹¸ì„ ëª¨ë‘ ë¬´ì‹œí•©ë‹ˆë‹¤.`);
      }

      if (cheats.shield2turn) {
        player.shieldChargesRemaining = 2;
        log(`ğŸ›¡ ì¹˜íŠ¸: ${player.name}ì´(ê°€) í•´ë¡œìš´ íš¨ê³¼ë¥¼ 2ë²ˆê¹Œì§€ ë§‰ì•„ì£¼ëŠ” ë³´í˜¸ë§‰ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
      }

      if (resetCells.includes(player.position)) {
        const trapPos = player.position;

        if (player.trapImmune) {
          log(`ğŸ§² í•¨ì • ì¹¸(${trapPos})ì— ë„ì°©í–ˆì§€ë§Œ, í•¨ì • ë¬´ì‹œ íš¨ê³¼ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.`);
        } else if (player.shieldChargesRemaining && player.shieldChargesRemaining > 0) {
          useShield(player, "trap");
        } else {
          log(`âš  ${player.name}ì´(ê°€) í•¨ì • ì¹¸(${trapPos})ì— ë„ì°©í•˜ì—¬ ì¶œë°œì ìœ¼ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.`);

          showCheatPopup(
            { color: "#fee2e2", bg: "#111827" },
            `í•¨ì • ì¹¸(${trapPos})! ì¶œë°œì ìœ¼ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.`,
            "í•¨ì •",
            "âš ",
            2000
          );

          if (gameContainerEl) {
            gameContainerEl.classList.add("shake");
            setTimeout(() => {
              gameContainerEl.classList.remove("shake");
            }, 400);
          }

          player.position = 0;
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.leadFollow) {
        let maxPos = -1;
        players.forEach((pl) => {
          if (pl.position > maxPos) maxPos = pl.position;
        });
        if (maxPos > 0) {
          const target = Math.max(0, Math.min(maxPos - 1, finishPos));
          if (target > player.position) {
            log(`ğŸƒ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì„ ë‘ ë°”ë¡œ ë’¤ ì¹¸(${target})ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
            player.position = target;
            renderTokens();
            updateStatusText();
          } else {
            log("ğŸƒ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ì— ê°€ê¹Œì›Œ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
          }
        }
      }

      if (cheats.swapLead) {
        let leader = players[0];
        players.forEach((pl) => {
          if (pl.position > leader.position) leader = pl;
        });

        if (leader === player) {
          log("ğŸ”„ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ë¼ êµí™˜ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        } else if (leader.shieldChargesRemaining && leader.shieldChargesRemaining > 0) {
          useShield(leader, "swap");
        } else {
          const tmp = player.position;
          player.position = leader.position;
          leader.position = tmp;
          log(`ğŸ”„ ì¹˜íŠ¸: ${player.name}ê³¼(ì™€) ${leader.name}ì˜ ìœ„ì¹˜ë¥¼ êµí™˜í–ˆìŠµë‹ˆë‹¤.`);
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.pushOthersBack) {
        players.forEach((pl) => {
          if (pl === player) return;
          if (pl.position > 0) {
            if (pl.shieldChargesRemaining && pl.shieldChargesRemaining > 0) {
              useShield(pl, "pushBack");
            } else {
              pl.position = pl.position - 1;
            }
          }
        });
        log(`â¬… ì¹˜íŠ¸: ${player.name}ì„(ë¥¼) ì œì™¸í•œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ 1ì¹¸ì”© ë’¤ë¡œ ë°€ë ¸ìŠµë‹ˆë‹¤.`);
        renderTokens();
        updateStatusText();
      }

      if (cheats.randomPlusMinus3) {
        const sign = Math.random() < 0.5 ? -1 : 1;
        const delta = 3 * sign;

        if (delta < 0 && player.shieldChargesRemaining && player.shieldChargesRemaining > 0) {
          useShield(player, "minus3");
        } else {
          const before = player.position;
          let after = before + delta;
          if (after < 0) after = 0;
          if (after > finishPos) after = finishPos;
          log(`ğŸ² ì¹˜íŠ¸: ${delta > 0 ? "+3" : "-3"}ì¹¸ ì´ë™ìœ¼ë¡œ ${before} â†’ ${after}`);
          player.position = after;
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.warpMiddle) {
        const middle = Math.floor(finishPos / 2);
        if (player.position !== middle) {
          log(`âœ¨ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì¤‘ì•™ ì¹¸(${middle})ìœ¼ë¡œ ì›Œí”„í–ˆìŠµë‹ˆë‹¤.`);
          player.position = middle;
          renderTokens();
          updateStatusText();
        } else {
          log("âœ¨ ì¹˜íŠ¸: ì´ë¯¸ ì¤‘ì•™ ì¹¸ì— ìˆì–´ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        }
      }

      if (cheats.warpLeadSkip) {
        let leader = players[0];
        players.forEach((pl) => {
          if (pl.position > leader.position) leader = pl;
        });

        if (leader === player) {
          log("ğŸ”¥ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ë¼ ì„ ë‘ ì›Œí”„ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        } else {
          const target = leader.position;
          log(`ğŸ”¥ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì„ ë‘ ìœ„ì¹˜(${target})ë¡œ ì›Œí”„í•©ë‹ˆë‹¤. (ë‹¤ìŒ ìê¸° ì°¨ë¡€ëŠ” ìë™ ìŠ¤í‚µ)`);
          player.position = target;
          renderTokens();
          updateStatusText();
          player.skipTurnsRemaining = (player.skipTurnsRemaining || 0) + 1;
        }
      }

      if (player.position === finishPos) {
        playSound("win");
        log(`ğŸ‰ ${player.name}ì´(ê°€) ì¹˜íŠ¸ íš¨ê³¼ë¡œ ë„ì°© ì§€ì ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ ì¢…ë£Œ!`);
        diceInfoEl.textContent = `${player.name} ìŠ¹ë¦¬! ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.`;
        gameOver = true;
        rollBtn.disabled = true;
        skipBtn.disabled = true;
        isRollingDice = false;
        isAnimating = false;
        return;
      }

      if (goldenKeyCells.includes(player.position)) {
        grantRandomCheatFromGoldenKey(player);
      }

      if (cheats.extraTurn) {
        log(`ğŸ” ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì´(ê°€) í•œ ë²ˆ ë” í„´ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
        isRollingDice = false;
        rollBtn.disabled = false;
        skipBtn.disabled = false;
        updateStatusText();
        return;
      }

      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      renderTokens();
      updateStatusText();
      isRollingDice = false;
      rollBtn.disabled = false;
      skipBtn.disabled = false;
    }

    function performMove(roll, cheats) {
      if (players.length === 0) return;
      const player = players[currentPlayerIndex];
      const startPos = player.position;
      const { multiplier, label } = getMultiplierInfo(startPos);

      if ((!cheats.triggered || cheats.triggered.length === 0) && multiplier !== 1) {
        const isBoost = multiplier > 1;
        const style = isBoost
          ? { color: "#fed7aa", bg: "#7c2d12" }
          : { color: "#bfdbfe", bg: "#020617" };
        const prefix = isBoost ? "x2 ë°°ì†" : "1/2 ë°°ì†";
        const msg = isBoost ? "ë¹ ë¥´ê²Œ ì „ì§„í•©ë‹ˆë‹¤!" : "ëŠë¦¬ê²Œ ì´ë™í•©ë‹ˆë‹¤.";
        const icon = isBoost ? "âš¡" : "ğŸ¢";
        showCheatPopup(style, msg, prefix, icon, 2000);
      }

      let extraFactor = cheats.doubleStep ? 2 : 1;
      if (cheats.doubleStep) {
        log("ğŸš€ ì¹˜íŠ¸ë¡œ ì´ë²ˆ ì´ë™ ê±°ë¦¬ê°€ 2ë°°ê°€ ë©ë‹ˆë‹¤.");
      }

      const isFast = (multiplier > 1) || cheats.doubleStep;
      player.isFastMoving = isFast;

      const effectiveSteps = Math.floor(roll * multiplier * extraFactor);

      const finishPos = BOARD_SIZE - 1;
      let targetPos = startPos + effectiveSteps;
      if (targetPos >= finishPos) targetPos = finishPos;
      const stepsToMove = targetPos - startPos;

      const baseMsg = `${player.name}ì´(ê°€) ì£¼ì‚¬ìœ„ ${roll}ì´(ê°€) ë‚˜ì™”ìŠµë‹ˆë‹¤. (${label})`;
      const moveMsg =
        stepsToMove <= 0
          ? `ë°°ìˆ˜ ì ìš© í›„ ì´ë™ ì¹¸: 0ì¹¸ (ì œìë¦¬)`
          : `ë°°ìˆ˜ ì ìš© í›„ ì´ë™ ì¹¸: ${stepsToMove}ì¹¸ â†’ ${startPos} â†’ ${targetPos}`;
      diceInfoEl.textContent = `${baseMsg} / ${moveMsg}`;
      log(`${baseMsg} ${moveMsg}`);

      if (stepsToMove <= 0) {
        player.isFastMoving = false;
        renderTokens();
        afterMoveCheck(player, cheats);
      } else {
        animateMove(player, stepsToMove, () => {
          player.isFastMoving = false;
          renderTokens();
          afterMoveCheck(player, cheats);
        });
      }
    }

    // ğŸ² ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°
    function startRoll() {
  // ğŸ”§ gameOver ì²´í¬ ì œê±°
  if (isAnimating || isRollingDice || players.length === 0) return;

      const player = players[currentPlayerIndex];
      if (player.skipTurnsRemaining && player.skipTurnsRemaining > 0) {
        player.skipTurnsRemaining--;
        log(`â­ï¸ ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì˜ í„´ì´ ìë™ìœ¼ë¡œ ìŠ¤í‚µë©ë‹ˆë‹¤.`);
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        renderTokens();
        updateStatusText();
        return;
      }

      const cheats = getCheatsForCurrentRoll();
      showCheatText(cheats);

      const hasCheat = cheats.triggered && cheats.triggered.length > 0;

      // ì¹˜íŠ¸ê°€ ì—†ì„ ë•Œ â†’ ë§ ìƒ‰ê¹” ê¸°ë°˜ ì—°í•œ ë„¤ì˜¨
      if (!hasCheat && player) {
        resetDiceStyle();
        setDiceNeonForColor(player.color);
      }

      if (!hasCheat) {
        playSound("dice");
      }

      isRollingDice = true;
      rollBtn.disabled = true;
      skipBtn.disabled = true;

      diceVisualEl.classList.remove("rolling");
      void diceVisualEl.offsetWidth;
      diceVisualEl.classList.add("rolling");

      let ticks = 0;
      const maxTicks = 10;
      const intervalMs = 80;

      const intervalId = setInterval(() => {
        const tempRoll = Math.floor(Math.random() * 6) + 1;
        setDiceFace(tempRoll);
        ticks++;
        if (ticks >= maxTicks) {
          clearInterval(intervalId);

          let finalRoll;
          if (cheats.goldenTen) {
            finalRoll = 15;
            log("âœ¨ ì¹˜íŠ¸: í™©ê¸ˆ ì£¼ì‚¬ìœ„(15)ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.");
          } else if (cheats.rerollHigher) {
            const r1 = Math.floor(Math.random() * 6) + 1;
            const r2 = Math.floor(Math.random() * 6) + 1;
            finalRoll = Math.max(r1, r2);
            log(`ğŸ² ì¹˜íŠ¸: ì¬êµ´ë¦¼ (${r1}, ${r2}) ì¤‘ ${finalRoll} ì‚¬ìš©.`);
          } else {
            finalRoll = Math.floor(Math.random() * 6) + 1;
          }

          setDiceFace(finalRoll);
          performMove(finalRoll, cheats);

          secretCodeInput.value = "";
        }
      }, intervalMs);
    }

    function skipTurn() {
      if (gameOver || isAnimating || isRollingDice || players.length === 0) return;

      const player = players[currentPlayerIndex];

      if (player.skipTurnsRemaining && player.skipTurnsRemaining > 0) {
        player.skipTurnsRemaining--;
        log(`â­ï¸ ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì˜ í„´ì´ ìë™ìœ¼ë¡œ ìŠ¤í‚µë©ë‹ˆë‹¤.`);
      } else {
        log(`â­ï¸ ${player.name}ì´(ê°€) ì´ë²ˆ í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤.`);
      }

      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      renderTokens();
      updateStatusText();
    }

    function setupGame() {
      let sizeVal = parseInt(boardSizeInput.value, 10);
      if (isNaN(sizeVal) || sizeVal < 6) sizeVal = 30;
      BOARD_SIZE = Math.max(6, Math.min(sizeVal, 200));

      specialZones = [];

      const x2Cells = parseCellList(x2CellsInput.value, BOARD_SIZE);
      x2Cells.forEach((n) => {
        specialZones.push({ start: n, end: n, multiplier: 2, label: "x2 ì¹¸" });
      });

      const halfCells = parseCellList(halfCellsInput.value, BOARD_SIZE);
      halfCells.forEach((n) => {
        specialZones.push({ start: n, end: n, multiplier: 0.5, label: "1/2 ì¹¸" });
      });

      resetCells = parseCellList(resetCellsInput.value, BOARD_SIZE);
      goldenKeyCells = parseCellList(gKeyCellsInput.value, BOARD_SIZE);

      const count = parseInt(playerCountSelect.value, 10);
      players = [];
      for (let i = 0; i < count; i++) {
        players.push({
          name: `í”Œë ˆì´ì–´ ${i + 1}`,
          position: 0,
          color: PLAYER_COLORS[i % PLAYER_COLORS.length],
          shieldChargesRemaining: 0,
          skipTurnsRemaining: 0,
          trapImmune: false,
          storedCheatCode: null,
          isFastMoving: false
        });
      }

      currentPlayerIndex = 0;
      gameOver = false;
      isAnimating = false;
      isRollingDice = false;

      renderBoard();
      renderTokens();
      renderPlayersLegend();
      updateLegendText();
      updateStatusText();

      logEl.innerHTML = "";
      diceVisualEl.textContent = "-";
      resetDiceStyle();
      diceInfoEl.textContent = "ğŸ² ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ê²Œì„ì„ ì‹œì‘í•´ ë³´ì„¸ìš”.";
      secretCodeInput.value = "";
      cheatTextEl.textContent = "ì¹˜íŠ¸: ì—†ìŒ";
      cheatTextEl.style.color = "#4b5563";
      rollBtn.disabled = false;
      skipBtn.disabled = false;

      applyTheme(themeSelect.value);
    }

    rollBtn.addEventListener("click", () => {
      startRoll();
    });

    skipBtn.addEventListener("click", () => {
      playSound("click");
      skipTurn();
    });

    startBtn.addEventListener("click", () => {
      playSound("click");
      setupGame();
    });

    themeSelect.addEventListener("change", (e) => {
      applyTheme(e.target.value);
    });

    if (cellEditButtons && cellEditButtons.length) {
      cellEditButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          cellEditButtons.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          cellEditMode = btn.dataset.mode || "off";
          playSound("click");
        });
      });
    }
    // ğŸ”Š / ğŸ”‡ íš¨ê³¼ìŒ ì¼œê¸°/ë„ê¸° í† ê¸€
    if (soundToggleBtn) {
      soundToggleBtn.addEventListener("click", () => {
        isSoundOn = !isSoundOn;
        soundToggleBtn.textContent = isSoundOn
          ? "ğŸ”Š íš¨ê³¼ìŒ ì¼œì§"
          : "ğŸ”‡ íš¨ê³¼ìŒ êº¼ì§";
        // ì¼œì§„ ìƒíƒœë¡œ ë°”ë€” ë•Œë§Œ ì‚´ì§ í´ë¦­ ì†Œë¦¬ ë‚´ê³  ì‹¶ìœ¼ë©´ ì•„ë˜ í•œ ì¤„ ì£¼ì„ í•´ì œ
        // if (isSoundOn) playSound("click");
      });

      // ì²˜ìŒ ë¡œë“œ ì‹œ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
      soundToggleBtn.textContent = "ğŸ”Š íš¨ê³¼ìŒ ì¼œì§";
    }

  // ğŸ”½ ì¹¸ í¸ì§‘ ëª¨ë“œ ì ‘ê¸° / í¼ì¹˜ê¸°
    if (cellEditToggleBtn && cellEditCardEl && cellEditBodyEl) {
      cellEditToggleBtn.addEventListener("click", () => {
        const collapsed = cellEditCardEl.classList.toggle("collapsed");
        if (collapsed) {
          cellEditToggleBtn.textContent = "ì¹¸ í¸ì§‘ ì—´ê¸° â–¼";
        } else {
          cellEditToggleBtn.textContent = "ì¹¸ í¸ì§‘ ì ‘ê¸° â–²";
        }
        playSound("click");
      });
    }

    applyTheme(themeSelect.value);
    setupGame();
  </script>
</body>
</html>
