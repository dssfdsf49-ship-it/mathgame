<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>슬리더링크 - 생성/플레이/솔버/유일성2해/PNG/SEED</title>
  <style>
    :root{
      --cell: 64;
      --pad: 24;
      --dot: 4;
      --edge: 7;
      --hit: 18;

      --bg:#ffffff;
      --ui:#111827;
      --muted:#6b7280;
      --panel:#f9fafb;
      --border:#e5e7eb;

      --line:#111827;
      --x:#9ca3af;

      --bad: rgba(239,68,68,.18);
      --good: rgba(34,197,94,.14);

      --sol: rgba(59,130,246,.22);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
    }
    body{margin:0;background:var(--bg);color:var(--ui);}
    .wrap{max-width:1220px;margin:0 auto;padding:16px;display:grid;gap:14px;grid-template-columns:520px 1fr;}
    @media (max-width: 980px){.wrap{grid-template-columns:1fr;}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 4px 18px rgba(0,0,0,.04);}
    h1{font-size:16px;margin:0 0 10px;}
    label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px;}
    input[type="number"], input[type="text"], select{
      padding:8px;border-radius:10px;border:1px solid var(--border);background:#fff;
      font-size:14px;
    }
    input[type="number"]{width:92px;}
    textarea{
      width:100%;min-height:170px;padding:10px;border-radius:12px;border:1px solid var(--border);
      resize:vertical;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size:13px;background:#fff;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    button{padding:9px 11px;border-radius:12px;border:1px solid var(--border);background:#fff;cursor:pointer;font-weight:900;}
    button:hover{background:#f3f4f6;}
    button.primary{background:#111827;color:#fff;border-color:#111827;}
    button.primary:hover{background:#0b1220;}
    button.warn{background:#fff7ed;border-color:#fed7aa;}
    button.warn:hover{background:#ffedd5;}
    .status{margin-top:10px;font-size:13px;line-height:1.45;}
    .status.ok{color:#166534;}
    .status.bad{color:#991b1b;}
    .hint{font-size:12px;color:var(--muted);line-height:1.5;}
    .boardWrap{display:grid;place-items:start;}
    svg{background:#fff;border:1px solid var(--border);border-radius:14px;}
    .clue{font-size:20px;font-weight:900;fill:#111827;opacity:.95;}
    .cellHL{fill:transparent;}
    .cellHL.bad{fill:var(--bad);}
    .cellHL.good{fill:var(--good);}
    .edgeLine{stroke:var(--line);stroke-width:var(--edge);stroke-linecap:round;opacity:0;}
    .edgeLine.on{opacity:1;}
    .edgeHit{fill:transparent;cursor:pointer;}
    .xMark{fill:var(--x);font-size:18px;font-weight:900;opacity:0;user-select:none;}
    .xMark.on{opacity:1;}
    .dot{fill:#111827;}
    .solLine{stroke:var(--sol);stroke-width:var(--edge);stroke-linecap:round;opacity:0;}
    .solLine.on{opacity:1;}
    .toggle{display:inline-flex;gap:8px;align-items:center;font-size:13px;color:var(--ui);}
    .chip{font-size:12px;padding:4px 8px;border:1px solid var(--border);border-radius:999px;background:#fff;color:var(--muted);}
    .small{font-size:12px;color:var(--muted);}
    .hr{height:1px;background:var(--border);margin:10px 0;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>슬리더링크(링 퍼즐)</h1>

      <div class="row">
        <div>
          <label>행(칸) (최대 10)</label>
          <input id="rows" type="number" min="2" max="10" value="10" />
        </div>
        <div>
          <label>열(칸) (최대 10)</label>
          <input id="cols" type="number" min="2" max="10" value="10" />
        </div>

        <div>
          <label>시드(Seed)</label>
          <input id="seed" type="text" placeholder="예: 1234 또는 hello" style="width:180px;" />

        </div>
<div class="toggle" style="margin-top:22px;" title="체크하면 같은 시드로 같은 퍼즐을 다시 생성합니다">
  <input id="lockSeed" type="checkbox" />
  <span>시드 고정</span>
</div>

        <span class="chip" id="seedInfo" title="랜덤 생성에 사용된 시드">seed: -</span>
        <span class="chip" title="선 클릭: 빈칸→선→X→빈칸">클릭: 빈→선→X</span>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>난이도(힌트 줄이기 정도)</label>
          <select id="difficulty">
            <option value="easy">왕초보</option>
            <option value="normal" selected>보통</option>
            <option value="hard">어려움</option>
            <option value="vhard">매우 어려움</option>
          </select>
        </div>

        <div>
          <label>힌트 밀도(숫자 빽빽함)</label>
          <select id="hintDensity">
            <option value="packed" selected>빽빽(거의 다 표시)</option>
            <option value="dense">많음</option>
            <option value="normal">보통</option>
            <option value="sparse">적음</option>
          </select>
        </div>

        <div class="toggle" style="margin-top:22px;" title="0을 퍼즐에서 덜 나오게 생성(또는 표시를 숨김)">
          <input id="hideZero" type="checkbox" checked />
          <span>0 숨기기</span>
        </div>

        <div class="toggle" style="margin-top:22px;" title="솔버/생성된 정답 루프를 연하게 표시합니다">
          <input id="showSolution" type="checkbox" />
          <span>솔루션 표시</span>
        </div>

        <div class="toggle" style="margin-top:22px;" title="클릭할 때마다 자동으로 검사합니다">
          <input id="autoCheck" type="checkbox" />
          <span>자동 검사</span>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="toggle" title="솔버가 CPU를 계속 100% 쓰지 않게 중간중간 쉬어갑니다(조금 느려질 수 있음)">
          <input id="lowPower" type="checkbox" checked />
          <span>저전력(쉬어가기)</span>
        </div>
        <span class="small" id="solInfo">해 표시: 없음</span>
      </div>

      <label>퍼즐 입력 (각 줄이 한 행, '.'은 빈칸, 0~3은 숫자)</label>
      <textarea id="puzzle" placeholder="여기에 퍼즐을 붙여넣고 [불러오기] 또는 [랜덤 생성]"></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="loadBtn">불러오기</button>
        <button id="randomBtn">랜덤 생성</button>
        <button id="checkBtn">검사</button>
        <button id="clearLinesBtn">선 지우기</button>
        <button id="clearAllBtn">전체 초기화</button>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button id="solveOneBtn" class="primary">해 1개 찾기(빠름)</button>
        <button id="solveUniqueBtn" class="warn">유일성 검사(느림)</button>
        <button id="nextSolBtn" disabled>다음 해(2개일 때)</button>
        <button id="stopSolveBtn">솔버 중지</button>
      </div>

<div class="row" style="margin-top:8px;">
  <button id="savePuzzlePngBtn">PNG 저장(퍼즐)</button>
  <button id="saveSolutionPngBtn">PNG 저장(솔루션)</button>

  <div class="toggle" title="PNG에 seed 정보를 같이 적어둡니다" style="margin-left:auto;">
    <input id="pngIncludeSeed" type="checkbox" />
    <span>PNG에 시드 포함</span>
  </div>

  <span class="small">※ 퍼즐 PNG: 숫자만 / 솔루션 PNG: 숫자+현재 선택된 해(파란선)</span>
</div>


      <div id="status" class="status">시작: 빈 보드로 표시됩니다. 퍼즐을 넣고 [불러오기] 또는 [랜덤 생성]을 눌러주세요.</div>

      <div class="hint" style="margin-top:10px;">
        목표: 숫자 칸은 주변 4변 중 <b>선(직선) 개수</b>가 숫자와 같아야 하고, 선 전체는 <b>교차 없는 하나의 닫힌 링</b>이어야 합니다.
      </div>
    </div>

    <div class="card boardWrap">
      <h1>보드</h1>
      <div id="boardHost"></div>
    </div>
  </div>

<script>
(() => {
  const elRows = document.getElementById('rows');
  const elCols = document.getElementById('cols');
  const elSeed = document.getElementById('seed');
  const elSeedInfo = document.getElementById('seedInfo');
  const elPngIncludeSeed = document.getElementById('pngIncludeSeed');
  const elLockSeed = document.getElementById('lockSeed');

  const elPuzzle = document.getElementById('puzzle');
  const elStatus = document.getElementById('status');

  const elDiff = document.getElementById('difficulty');
  const elDensity = document.getElementById('hintDensity');
  const elHideZero = document.getElementById('hideZero');
  const elShowSol = document.getElementById('showSolution');
  const elAuto = document.getElementById('autoCheck');
  const elLowPower = document.getElementById('lowPower');

  const elSolInfo = document.getElementById('solInfo');
  const btnNextSol = document.getElementById('nextSolBtn');
  const host = document.getElementById('boardHost');

  const CELL = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'), 10);
  const PAD  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad'), 10);
  const DOT  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dot'), 10);
  const HIT  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--hit'), 10);
  const EDGEW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--edge'), 10);

  let R = 10, C = 10;
  let clues = [];              // R x C, -1 blank
  let H = [];                  // (R+1) x C: 0 empty, 1 line, 2 X
  let V = [];                  // R x (C+1)

  // 저장된 솔루션(최대 2개)
  let solutions = [];          // [{h:boolean[][], v:boolean[][]}, ...]
  let solIndex = 0;
  let solH = null;
  let solV = null;

  let svg;
  let edgeLineMap = new Map();
  let solLineMap  = new Map();
  let xMarkMap = new Map();
  let cellHLMap = new Map();

  let solveToken = 0;

  // ---------------- SEED RNG ----------------
  let rng = Math.random;

  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for (let i=0;i<str.length;i++){
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      h ^= (h >>> 16);
      return h >>> 0;
    };
  }
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function rand01(){ return rng(); }

  function makeAutoSeedString(){
    // 빈 시드면 자동 생성해서 입력칸에 넣어줌(재현 가능하게)
    if (window.crypto && crypto.getRandomValues){
      const a = new Uint32Array(1);
      crypto.getRandomValues(a);
      return String(a[0] >>> 0);
    }
    return String((Date.now() ^ (Math.random()*0xFFFFFFFF)) >>> 0);
  }

  function setSeedAndRng(){
    let s = (elSeed.value || '').trim();
    if (!s){
      s = makeAutoSeedString();
      elSeed.value = s;
    }

    let seedNum;
    if (/^\d+$/.test(s)) seedNum = (Number(s) >>> 0);
    else seedNum = xmur3(s)();

    rng = mulberry32(seedNum >>> 0);
    elSeedInfo.textContent = `seed: ${s}`;
  }

  // seed 칩은 입력만 해도 표시만 바뀌게(실제 적용은 생성 버튼에서)
  elSeed.addEventListener('input', () => {
    const s = (elSeed.value || '').trim();
    elSeedInfo.textContent = s ? `seed: ${s}` : 'seed: -';
  });

  // ---------------- UI helpers ----------------
  function setStatus(msg, ok=null){
    elStatus.textContent = msg;
    elStatus.classList.remove('ok','bad');
    if (ok === true) elStatus.classList.add('ok');
    if (ok === false) elStatus.classList.add('bad');
  }

  function make2D(rows, cols, fill=0){
    return Array.from({length: rows}, () => Array.from({length: cols}, () => fill));
  }

  function parsePuzzle(text, r, c){
    const lines = text.trim().split('\n').map(s => s.trim()).filter(Boolean);
    if (lines.length !== r) throw new Error(`입력 행 수가 ${r}개여야 합니다. (현재 ${lines.length}개)`);
    const g = make2D(r, c, -1);
    for (let i=0;i<r;i++){
      if (lines[i].length !== c) throw new Error(`(${i+1}행) 글자 수가 ${c}개여야 합니다.`);
      for (let j=0;j<c;j++){
        const ch = lines[i][j];
        if (ch === '.' || ch === ' ') g[i][j] = -1;
        else if (ch >= '0' && ch <= '3') g[i][j] = ch.charCodeAt(0)-48;
        else throw new Error(`(${i+1}행, ${j+1}열) '.' 또는 0~3만 허용: '${ch}'`);
      }
    }
    return g;
  }

  function resetEdges(){
    H = make2D(R+1, C, 0);
    V = make2D(R, C+1, 0);
  }

  function clearSolutions(){
    solutions = [];
    solIndex = 0;
    solH = null; solV = null;
    elShowSol.checked = false;
    btnNextSol.disabled = true;
    updateSolInfo();
  }

  function applySolutionIndex(i){
    if (solutions.length === 0) return;
    solIndex = (i % solutions.length + solutions.length) % solutions.length;
    solH = solutions[solIndex].h;
    solV = solutions[solIndex].v;
    elShowSol.checked = true; // solve 결과는 기본 ON
    btnNextSol.disabled = (solutions.length < 2);
    updateSolInfo();
    redrawAll();
  }

  function updateSolInfo(){
    if (solutions.length === 0){
      elSolInfo.textContent = '해 표시: 없음';
      return;
    }
    elSolInfo.textContent = `해 표시: ${solIndex+1}/${solutions.length}`;
  }

  function buildSVG(){
    host.innerHTML = '';
    edgeLineMap.clear(); solLineMap.clear(); xMarkMap.clear(); cellHLMap.clear();

    const w = PAD*2 + C*CELL;
    const h = PAD*2 + R*CELL;

    svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', w);
    svg.setAttribute('height', h);
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);

    // cells + clues
    for (let r=0;r<R;r++){
      for (let c=0;c<C;c++){
        const x = PAD + c*CELL;
        const y = PAD + r*CELL;

        const hl = document.createElementNS(svg.namespaceURI,'rect');
        hl.setAttribute('x', x);
        hl.setAttribute('y', y);
        hl.setAttribute('width', CELL);
        hl.setAttribute('height', CELL);
        hl.setAttribute('rx', 10);
        hl.setAttribute('class', 'cellHL');
        svg.appendChild(hl);
        cellHLMap.set(`cell:${r},${c}`, hl);

        const v = clues[r][c];
        if (v >= 0){
          // 0 숨기기(표시만 숨김, 조건은 그대로 유지)
          if (elHideZero.checked && v === 0) continue;

          const t = document.createElementNS(svg.namespaceURI,'text');
          t.setAttribute('x', x + CELL/2);
          t.setAttribute('y', y + CELL/2 + 7);
          t.setAttribute('text-anchor','middle');
          t.setAttribute('class','clue');
          t.textContent = String(v);
          svg.appendChild(t);
        }
      }
    }

    function addEdge(kind, r, c, x1,y1,x2,y2){
      const id = `${kind}:${r},${c}`;

      const sline = document.createElementNS(svg.namespaceURI,'line');
      sline.setAttribute('x1', x1); sline.setAttribute('y1', y1);
      sline.setAttribute('x2', x2); sline.setAttribute('y2', y2);
      sline.setAttribute('class','solLine');
      svg.appendChild(sline);
      solLineMap.set(id, sline);

      const line = document.createElementNS(svg.namespaceURI,'line');
      line.setAttribute('x1', x1); line.setAttribute('y1', y1);
      line.setAttribute('x2', x2); line.setAttribute('y2', y2);
      line.setAttribute('class','edgeLine');
      svg.appendChild(line);
      edgeLineMap.set(id, line);

      const mx = (x1+x2)/2, my = (y1+y2)/2;
      const xmark = document.createElementNS(svg.namespaceURI,'text');
      xmark.setAttribute('x', mx);
      xmark.setAttribute('y', my+6);
      xmark.setAttribute('text-anchor','middle');
      xmark.setAttribute('class','xMark');
      xmark.textContent = '×';
      svg.appendChild(xmark);
      xMarkMap.set(id, xmark);

      const hit = document.createElementNS(svg.namespaceURI,'rect');
      if (kind === 'h'){
        hit.setAttribute('x', Math.min(x1,x2));
        hit.setAttribute('y', my - HIT/2);
        hit.setAttribute('width', Math.abs(x2-x1));
        hit.setAttribute('height', HIT);
      } else {
        hit.setAttribute('x', mx - HIT/2);
        hit.setAttribute('y', Math.min(y1,y2));
        hit.setAttribute('width', HIT);
        hit.setAttribute('height', Math.abs(y2-y1));
      }
      hit.setAttribute('class','edgeHit');
      hit.dataset.kind = kind;
      hit.dataset.r = r;
      hit.dataset.c = c;
      hit.addEventListener('click', onEdgeClick);
      svg.appendChild(hit);
    }

    // horizontal edges
    for (let r=0;r<=R;r++){
      for (let c=0;c<C;c++){
        const x1 = PAD + c*CELL, y1 = PAD + r*CELL;
        const x2 = PAD + (c+1)*CELL, y2 = y1;
        addEdge('h', r, c, x1,y1,x2,y2);
      }
    }
    // vertical edges
    for (let r=0;r<R;r++){
      for (let c=0;c<=C;c++){
        const x1 = PAD + c*CELL, y1 = PAD + r*CELL;
        const x2 = x1, y2 = PAD + (r+1)*CELL;
        addEdge('v', r, c, x1,y1,x2,y2);
      }
    }

    // dots
    for (let r=0;r<=R;r++){
      for (let c=0;c<=C;c++){
        const cx = PAD + c*CELL;
        const cy = PAD + r*CELL;
        const dot = document.createElementNS(svg.namespaceURI,'circle');
        dot.setAttribute('cx', cx);
        dot.setAttribute('cy', cy);
        dot.setAttribute('r', DOT);
        dot.setAttribute('class','dot');
        svg.appendChild(dot);
      }
    }

    host.appendChild(svg);
    redrawAll();
  }

  function getEdgeState(kind, r, c){ return kind === 'h' ? H[r][c] : V[r][c]; }
  function setEdgeState(kind, r, c, val){ if (kind === 'h') H[r][c] = val; else V[r][c] = val; }

  function redrawEdge(kind, r, c){
    const id = `${kind}:${r},${c}`;
    const line = edgeLineMap.get(id);
    const xmark = xMarkMap.get(id);
    const sline = solLineMap.get(id);

    const st = getEdgeState(kind, r, c);
    line.classList.toggle('on', st === 1);
    xmark.classList.toggle('on', st === 2);

    const solOn = !!(solH && solV) && elShowSol.checked && (
      (kind === 'h' ? solH[r][c] : solV[r][c])
    );
    sline.classList.toggle('on', solOn);
  }

  function redrawAll(){
    for (let r=0;r<=R;r++) for (let c=0;c<C;c++) redrawEdge('h', r, c);
    for (let r=0;r<R;r++) for (let c=0;c<=C;c++) redrawEdge('v', r, c);
    if (elAuto.checked) checkAll();
  }

  function onEdgeClick(e){
    const kind = e.currentTarget.dataset.kind;
    const r = parseInt(e.currentTarget.dataset.r, 10);
    const c = parseInt(e.currentTarget.dataset.c, 10);
    const st = getEdgeState(kind, r, c);
    const next = (st + 1) % 3;
    setEdgeState(kind, r, c, next);
    redrawEdge(kind, r, c);
    if (elAuto.checked) checkAll();
  }

  function cellLineCount(r, c){
    let cnt = 0;
    if (H[r][c] === 1) cnt++;
    if (H[r+1][c] === 1) cnt++;
    if (V[r][c] === 1) cnt++;
    if (V[r][c+1] === 1) cnt++;
    return cnt;
  }

  function checkClues(){
    let ok = true;
    for (let r=0;r<R;r++){
      for (let c=0;c<C;c++){
        const clue = clues[r][c];
        const hl = cellHLMap.get(`cell:${r},${c}`);
        hl.setAttribute('class','cellHL');
        if (clue >= 0){
          const cnt = cellLineCount(r,c);
          if (cnt !== clue){ hl.classList.add('bad'); ok = false; }
          else hl.classList.add('good');
        }
      }
    }
    return ok;
  }

  function keyOf(v){ return `${v[0]},${v[1]}`; }

  function checkSingleLoopFromEdges(Hlike, Vlike){
    const deg = new Map();
    const adj = new Map();
    let edgeCount = 0;

    function addEdge(a,b){
      const ka=keyOf(a), kb=keyOf(b);
      deg.set(ka, (deg.get(ka)||0)+1);
      deg.set(kb, (deg.get(kb)||0)+1);
      if (!adj.has(ka)) adj.set(ka, []);
      if (!adj.has(kb)) adj.set(kb, []);
      adj.get(ka).push(kb);
      adj.get(kb).push(ka);
      edgeCount++;
    }

    for (let r=0;r<=R;r++){
      for (let c=0;c<C;c++){
        if (Hlike[r][c]) addEdge([r,c],[r,c+1]);
      }
    }
    for (let r=0;r<R;r++){
      for (let c=0;c<=C;c++){
        if (Vlike[r][c]) addEdge([r,c],[r+1,c]);
      }
    }

    if (edgeCount === 0) return { ok:false, msg:'선이 아직 없어요.' };
    for (const [k,d] of deg.entries()){
      if (d !== 2) return { ok:false, msg:`고리 조건 위반: 점(${k})에서 선 ${d}개.` };
    }

    const start = deg.keys().next().value;
    const stack=[start];
    const visited=new Set([start]);
    while(stack.length){
      const cur = stack.pop();
      for (const nx of (adj.get(cur)||[])){
        if(!visited.has(nx)){ visited.add(nx); stack.push(nx); }
      }
    }
    if (visited.size !== deg.size) return { ok:false, msg:'고리 조건 위반: 분리된 선이 있어요.' };
    return { ok:true, msg:'단일 링 OK' };
  }

  function checkSingleLoopPlayer(){
    const Hlike = make2D(R+1, C, false);
    const Vlike = make2D(R, C+1, false);
    for (let r=0;r<=R;r++) for (let c=0;c<C;c++) Hlike[r][c] = (H[r][c]===1);
    for (let r=0;r<R;r++) for (let c=0;c<=C;c++) Vlike[r][c] = (V[r][c]===1);
    return checkSingleLoopFromEdges(Hlike, Vlike);
  }

  function checkAll(){
    const cluesOk = checkClues();
    const loop = checkSingleLoopPlayer();
    if (cluesOk && loop.ok){
      setStatus('✅ 정답! 숫자 조건 + 단일 링 모두 만족.', true);
      return true;
    }
    const parts = [];
    if (!cluesOk) parts.push('숫자 조건 불일치(빨간 칸).');
    if (!loop.ok) parts.push(loop.msg);
    setStatus('⚠️ ' + parts.join(' / '), false);
    return false;
  }

  function ensureEmptyPuzzleText(){
    if (!elPuzzle.value.trim()){
      elPuzzle.value = Array.from({length:R}, () => '.'.repeat(C)).join('\n');
    }
  }

  function loadPuzzle(){
    try{
      solveToken++;
      R = Math.min(10, parseInt(elRows.value,10));
      C = Math.min(10, parseInt(elCols.value,10));
      elRows.value = String(R);
      elCols.value = String(C);

      ensureEmptyPuzzleText();

      clues = parsePuzzle(elPuzzle.value, R, C);
      resetEdges();
      clearSolutions();
      buildSVG();
      setStatus(elAuto.checked ? '불러오기 완료.' : '자동 검사는 꺼져 있어요. 필요할 때 [검사]를 누르세요.');
    }catch(err){
      setStatus(String(err.message||err), false);
    }
  }

  function clearLines(){
    solveToken++;
    resetEdges();
    redrawAll();
    setStatus('선만 지웠어요.');
  }

  function clearAll(){
    solveToken++;
    R = Math.min(10, parseInt(elRows.value,10));
    C = Math.min(10, parseInt(elCols.value,10));
    elRows.value = String(R);
    elCols.value = String(C);
    elPuzzle.value = '';
    ensureEmptyPuzzleText();
    clues = parsePuzzle(elPuzzle.value, R, C);
    resetEdges();
    clearSolutions();
    buildSVG();
    setStatus('전체 초기화 완료(빈 보드).');
  }

  // ---------- 랜덤 생성(숫자 빽빽 + 0 억제) ----------
  function randInt(a,b){ return Math.floor(rand01()*(b-a+1))+a; }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(rand01()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function hasHoles(region){
    const vis = make2D(R, C, false);
    const q = [];
    for(let c=0;c<C;c++){
      if(!region[0][c]){ vis[0][c]=true; q.push([0,c]); }
      if(!region[R-1][c]){ vis[R-1][c]=true; q.push([R-1,c]); }
    }
    for(let r=0;r<R;r++){
      if(!region[r][0]){ vis[r][0]=true; q.push([r,0]); }
      if(!region[r][C-1]){ vis[r][C-1]=true; q.push([r,C-1]); }
    }
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const [r,c]=q.shift();
      for(const [dr,dc] of dirs){
        const nr=r+dr,nc=c+dc;
        if(nr<0||nr>=R||nc<0||nc>=C) continue;
        if(region[nr][nc]) continue;
        if(vis[nr][nc]) continue;
        vis[nr][nc]=true;
        q.push([nr,nc]);
      }
    }
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        if(!region[r][c] && !vis[r][c]) return true;
      }
    }
    return false;
  }

  function regionToBoundary(region){
    const keys = new Set();
    function toggle(k){ if(keys.has(k)) keys.delete(k); else keys.add(k); }
    let cellCount=0;
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        if(!region[r][c]) continue;
        cellCount++;
        toggle(`h:${r},${c}`);
        toggle(`h:${r+1},${c}`);
        toggle(`v:${r},${c}`);
        toggle(`v:${r},${c+1}`);
      }
    }
    const sH = make2D(R+1, C, false);
    const sV = make2D(R, C+1, false);
    for(const k of keys){
      const [kind, rest] = k.split(':');
      const [rr,cc] = rest.split(',').map(Number);
      if(kind==='h') sH[rr][cc]=true;
      else sV[rr][cc]=true;
    }
    return { sH, sV, cellCount };
  }

  function computeCluesFromSolution(sH, sV){
    const g = make2D(R, C, -1);
    let nonZero = 0;
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        let cnt=0;
        if(sH[r][c]) cnt++;
        if(sH[r+1][c]) cnt++;
        if(sV[r][c]) cnt++;
        if(sV[r][c+1]) cnt++;
        g[r][c]=cnt;
        if (cnt !== 0) nonZero++;
      }
    }
    return { grid: g, nonZero };
  }

  function getKeepProb(){
    const base =
      (elDiff.value === 'easy')  ? 0.78 :
      (elDiff.value === 'hard')  ? 0.50 :
      (elDiff.value === 'vhard') ? 0.35 :
                                   0.62;

    const mul =
      (elDensity.value === 'packed') ? 1.45 :
      (elDensity.value === 'dense')  ? 1.20 :
      (elDensity.value === 'normal') ? 1.00 :
                                       0.78;

    return Math.min(0.98, base * mul);
  }

  function requiredNonZeroDensity(){
    if (elDensity.value === 'packed') return 0.58;
    if (elDensity.value === 'dense')  return 0.48;
    if (elDensity.value === 'normal') return 0.38;
    return 0.30;
  }

  function cluesToTextWeighted(g, keepProb){
    let out = [];
    let kept = 0;

    for (let r=0;r<R;r++){
      let line = '';
      for (let c=0;c<C;c++){
        const v = g[r][c];

        let p = keepProb;
        // 0은 확 줄이고, 3/2는 더 남기기
        if (v === 0) p *= 0.08;
        else if (v === 1) p *= 1.05;
        else if (v === 2) p *= 1.12;
        else if (v === 3) p *= 1.18;

        // 0 숨기기 옵션이면 "표시 자체를 '.'로" 만들어 0이 퍼즐에 덜 보이게
        if (elHideZero.checked && v === 0){
          line += '.';
          continue;
        }

        if (rand01() < Math.min(1, p)){
          line += String(v);
          kept++;
        } else {
          line += '.';
        }
      }
      out.push(line);
    }
    return { text: out.join('\n'), kept };
  }

  function generateRandom(){
    solveToken++;
    R = Math.min(10, parseInt(elRows.value,10));
    C = Math.min(10, parseInt(elCols.value,10));
    elRows.value = String(R);
    elCols.value = String(C);

// ✅ 시드 고정이 아니면, 매번 새 시드를 뽑아서 진짜 랜덤 생성
if (!elLockSeed.checked) elSeed.value = '';
setSeedAndRng();


    // ✅ 시드 적용(이후 랜덤은 전부 rand01로 고정 재현)
    setSeedAndRng();

    const keepProb = getKeepProb();
    const needNZ = requiredNonZeroDensity();
    const MAX_TRY = 900;

    for (let t=0; t<MAX_TRY; t++){
      const region = make2D(R, C, false);
      const target = randInt(Math.floor(R*C*0.35), Math.floor(R*C*0.60));
      let sr = randInt(0,R-1), sc = randInt(0,C-1);
      region[sr][sc]=true;

      const cells = [[sr,sc]];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

      let guard = 0;
      while(cells.length < target && guard < target * 80){
        guard++;
        const pickLast = rand01() < 0.70;
        const [r,c] = pickLast ? cells[cells.length-1] : cells[randInt(0, cells.length-1)];
        const nbs = shuffle(dirs.map(([dr,dc]) => [r+dr, c+dc]))
          .filter(([nr,nc]) => nr>=0 && nr<R && nc>=0 && nc<C && !region[nr][nc]);
        if(nbs.length===0) continue;
        const [nr,nc] = nbs[0];
        region[nr][nc] = true;
        cells.push([nr,nc]);
      }

      if (hasHoles(region)) continue;

      const { sH, sV, cellCount } = regionToBoundary(region);
      if (cellCount < 3) continue;

      const chk = checkSingleLoopFromEdges(sH, sV);
      if (!chk.ok) continue;

      const { grid: full, nonZero } = computeCluesFromSolution(sH, sV);
      const nzDensity = nonZero / (R*C);
      if (nzDensity < needNZ) continue;

      const built = cluesToTextWeighted(full, keepProb);
      const shownDensity = built.kept / (R*C);
      const minShown =
        (elDensity.value === 'packed') ? 0.55 :
        (elDensity.value === 'dense')  ? 0.42 :
        (elDensity.value === 'normal') ? 0.30 : 0.22;
      if (shownDensity < minShown) continue;

      elPuzzle.value = built.text;
      clues = parsePuzzle(elPuzzle.value, R, C);

      resetEdges();
      clearSolutions();

      // 솔루션 저장(정답 루프는 보관), 생성 직후엔 "표시 OFF"
      solutions = [{h: sH, v: sV}];
      applySolutionIndex(0);        // solH/solV 세팅
      elShowSol.checked = false;    // ✅ 생성 버튼 후 기본 OFF
      buildSVG();

      const diffText = elDiff.options[elDiff.selectedIndex].text;
      const densText = elDensity.options[elDensity.selectedIndex].text;
      setStatus(`랜덤 생성 완료! (난이도: ${diffText}, 밀도: ${densText})`, true);
      redrawAll();
      return;
    }
    setStatus('랜덤 생성 실패(조건이 빡빡). 밀도를 “많음”으로 낮추거나 다시 눌러보세요.', false);
  }

  // ---------- 솔버 ----------
  function stopSolve(){
    solveToken++;
    setStatus('솔버 중지 요청. (다음 쉬어가기 지점에서 멈춥니다.)');
  }

  async function solve(mode){
    const myToken = ++solveToken;

    try{
      R = Math.min(10, parseInt(elRows.value,10));
      C = Math.min(10, parseInt(elCols.value,10));
      elRows.value = String(R);
      elCols.value = String(C);

      ensureEmptyPuzzleText();
      clues = parsePuzzle(elPuzzle.value, R, C);

      clearSolutions();

      const timeLimitMs = (mode === 'one') ? 2500 : 12000;
      const deadline = performance.now() + timeLimitMs;

      setStatus(mode === 'one'
        ? '해 1개 찾는 중...'
        : '유일성 검사 중... (해 2개 이상 찾으면 중단)'
      );

      const result = await solveCore(clues, deadline, mode, myToken);
      if (myToken !== solveToken) return;

      if (result.count === 0){
        clearSolutions();
        redrawAll();
        setStatus('❌ 해가 없습니다(모순). 입력 퍼즐을 확인해보세요.', false);
        return;
      }

      solutions = result.sols;
      applySolutionIndex(0);

      if (result.count === 1){
        setStatus('✅ 해 1개(유일해)입니다. 솔루션을 표시했어요.', true);
      } else {
        setStatus('⚠️ 해가 2개 이상입니다(비유일). [다음 해]로 번갈아 볼 수 있어요.', false);
      }

    } catch (e){
      if (myToken !== solveToken) return;
      setStatus(String(e.message || e), false);
    }
  }

  async function solveCore(cluesGrid, deadline, mode, token){
    const RR = R, CC = C;
    const SH = make2D(RR+1, CC, -1);
    const SV = make2D(RR, CC+1, -1);

    const cellQ = new Set();
    const vertQ = new Set();
    for (let r=0;r<RR;r++) for (let c=0;c<CC;c++) if (cluesGrid[r][c] >= 0) cellQ.add(r*CC+c);
    for (let vr=0;vr<=RR;vr++) for (let vc=0;vc<=CC;vc++) vertQ.add(vr*(CC+1)+vc);

    let solCount = 0;
    const found = []; // 최대 2개만 저장

    function cellEdges(r,c){
      return [
        {kind:'h', r:r,   c:c},
        {kind:'h', r:r+1, c:c},
        {kind:'v', r:r,   c:c},
        {kind:'v', r:r,   c:c+1}
      ];
    }
    function vertexEdges(vr,vc){
      const out = [];
      if (vc>0) out.push({kind:'h', r:vr, c:vc-1});
      if (vc<CC) out.push({kind:'h', r:vr, c:vc});
      if (vr>0) out.push({kind:'v', r:vr-1, c:vc});
      if (vr<RR) out.push({kind:'v', r:vr, c:vc});
      return out;
    }

    function getS(kind,r,c){ return kind==='h' ? SH[r][c] : SV[r][c]; }

    function setS(kind,r,c,val,trail){
      const cur = getS(kind,r,c);
      if (cur === val) return true;
      if (cur !== -1 && cur !== val) return false;

      trail.push({kind,r,c,prev:cur});
      if (kind==='h') SH[r][c]=val; else SV[r][c]=val;

      if (kind==='h'){
        if (r>0 && r-1<RR && c>=0 && c<CC && cluesGrid[r-1][c]>=0) cellQ.add((r-1)*CC+c);
        if (r<RR && c>=0 && c<CC && cluesGrid[r][c]>=0) cellQ.add(r*CC+c);
        vertQ.add(r*(CC+1)+c);
        vertQ.add(r*(CC+1)+(c+1));
      } else {
        if (c>0 && c-1<CC && r>=0 && r<RR && cluesGrid[r][c-1]>=0) cellQ.add(r*CC+(c-1));
        if (c<CC && r>=0 && r<RR && cluesGrid[r][c]>=0) cellQ.add(r*CC+c);
        vertQ.add(r*(CC+1)+c);
        vertQ.add((r+1)*(CC+1)+c);
      }
      return true;
    }

    function undo(trail){
      for (let i=trail.length-1;i>=0;i--){
        const t = trail[i];
        if (t.kind==='h') SH[t.r][t.c]=t.prev;
        else SV[t.r][t.c]=t.prev;
      }
    }

    function prematureCycleCheck(){
      const deg = new Map();
      const adj = new Map();
      let edgeCount = 0;

      function add(a,b){
        if (!adj.has(a)) adj.set(a, []);
        if (!adj.has(b)) adj.set(b, []);
        adj.get(a).push(b);
        adj.get(b).push(a);
        deg.set(a, (deg.get(a)||0)+1);
        deg.set(b, (deg.get(b)||0)+1);
        edgeCount++;
      }

      for (let r=0;r<=RR;r++){
        for (let c=0;c<CC;c++){
          if (SH[r][c]===1) add(`${r},${c}`, `${r},${c+1}`);
        }
      }
      for (let r=0;r<RR;r++){
        for (let c=0;c<=CC;c++){
          if (SV[r][c]===1) add(`${r},${c}`, `${r+1},${c}`);
        }
      }
      if (edgeCount === 0) return true;

      const seen = new Set();
      for (const v of deg.keys()){
        if (seen.has(v)) continue;
        const stack=[v];
        const comp=[];
        seen.add(v);
        while(stack.length){
          const cur=stack.pop();
          comp.push(cur);
          for (const nx of (adj.get(cur)||[])){
            if(!seen.has(nx)){ seen.add(nx); stack.push(nx); }
          }
        }
        let all2 = true;
        for (const x of comp){
          if ((deg.get(x)||0) !== 2){ all2 = false; break; }
        }
        if (all2){
          const setComp = new Set(comp);
          for (let r=0;r<=RR;r++){
            for (let c=0;c<CC;c++){
              if (SH[r][c]!==1) continue;
              const a = `${r},${c}`;
              const b = `${r},${c+1}`;
              if (!setComp.has(a) || !setComp.has(b)) return false;
            }
          }
          for (let r=0;r<RR;r++){
            for (let c=0;c<=CC;c++){
              if (SV[r][c]!==1) continue;
              const a = `${r},${c}`;
              const b = `${r+1},${c}`;
              if (!setComp.has(a) || !setComp.has(b)) return false;
            }
          }
        }
      }
      return true;
    }

    function propagate(trail){
      while (cellQ.size>0 || vertQ.size>0){
        if (token !== solveToken) throw new Error('솔버 중지됨.');
        if (performance.now() > deadline) throw new Error('시간 제한 초과(솔버).');

        while (cellQ.size>0){
          const it = cellQ.values().next().value;
          cellQ.delete(it);
          const r = Math.floor(it / CC);
          const c = it % CC;
          const clue = cluesGrid[r][c];
          if (clue < 0) continue;

          const edges = cellEdges(r,c);
          let line=0, unk=0;
          const unkEdges=[];
          for (const e of edges){
            const v = getS(e.kind,e.r,e.c);
            if (v === 1) line++;
            else if (v === -1){ unk++; unkEdges.push(e); }
          }
          if (line > clue) return false;
          if (line + unk < clue) return false;

          if (unk > 0){
            if (line === clue){
              for (const e of unkEdges) if (!setS(e.kind,e.r,e.c,0,trail)) return false;
            } else if (line + unk === clue){
              for (const e of unkEdges) if (!setS(e.kind,e.r,e.c,1,trail)) return false;
            }
          }
        }

        while (vertQ.size>0){
          const it = vertQ.values().next().value;
          vertQ.delete(it);
          const vr = Math.floor(it / (CC+1));
          const vc = it % (CC+1);

          const edges = vertexEdges(vr,vc);
          let line=0, unk=0;
          const unkEdges=[];
          for (const e of edges){
            const v = getS(e.kind,e.r,e.c);
            if (v === 1) line++;
            else if (v === -1){ unk++; unkEdges.push(e); }
          }
          if (line > 2) return false;

          if (line === 2){
            for (const e of unkEdges) if (!setS(e.kind,e.r,e.c,0,trail)) return false;
          } else if (line === 1){
            if (unk === 0) return false;
            if (unk === 1){
              const e = unkEdges[0];
              if (!setS(e.kind,e.r,e.c,1,trail)) return false;
            }
          } else {
            if (unk === 1){
              const e = unkEdges[0];
              if (!setS(e.kind,e.r,e.c,0,trail)) return false;
            }
          }
        }

        if (!prematureCycleCheck()) return false;
      }
      return true;
    }

    function allAssigned(){
      for (let r=0;r<=RR;r++) for (let c=0;c<CC;c++) if (SH[r][c]===-1) return false;
      for (let r=0;r<RR;r++) for (let c=0;c<=CC;c++) if (SV[r][c]===-1) return false;
      return true;
    }

    function finalSingleLoop(){
      const Hlike = make2D(RR+1, CC, false);
      const Vlike = make2D(RR, CC+1, false);
      for (let r=0;r<=RR;r++) for (let c=0;c<CC;c++) Hlike[r][c] = (SH[r][c]===1);
      for (let r=0;r<RR;r++) for (let c=0;c<=CC;c++) Vlike[r][c] = (SV[r][c]===1);

      const oldR = R, oldC = C;
      R = RR; C = CC;
      const chk = checkSingleLoopFromEdges(Hlike, Vlike);
      R = oldR; C = oldC;
      return chk.ok;
    }

    function pickNextEdge(){
      let best = null;
      let bestScore = -1;
      function scoreEdge(kind,r,c){
        let score = 0;
        if (kind==='h'){
          if (r>0 && cluesGrid[r-1][c]>=0) score += 3;
          if (r<RR && cluesGrid[r][c]>=0) score += 3;
          score += 2;
        } else {
          if (c>0 && cluesGrid[r][c-1]>=0) score += 3;
          if (c<CC && cluesGrid[r][c]>=0) score += 3;
          score += 2;
        }
        return score;
      }
      for (let r=0;r<=RR;r++){
        for (let c=0;c<CC;c++){
          if (SH[r][c]===-1){
            const sc = scoreEdge('h',r,c);
            if (sc > bestScore){ bestScore=sc; best={kind:'h',r,c}; }
          }
        }
      }
      for (let r=0;r<RR;r++){
        for (let c=0;c<=CC;c++){
          if (SV[r][c]===-1){
            const sc = scoreEdge('v',r,c);
            if (sc > bestScore){ bestScore=sc; best={kind:'v',r,c}; }
          }
        }
      }
      return best;
    }

    function snapshot(){
      const h = make2D(RR+1, CC, false);
      const v = make2D(RR, CC+1, false);
      for (let r=0;r<=RR;r++) for (let c=0;c<CC;c++) h[r][c] = (SH[r][c]===1);
      for (let r=0;r<RR;r++) for (let c=0;c<=CC;c++) v[r][c] = (SV[r][c]===1);
      return {h,v};
    }

    let lastYield = performance.now();
    async function maybeYield(){
      if (!elLowPower.checked) return;
      const now = performance.now();
      if (now - lastYield > 16){
        await new Promise(r => setTimeout(r, 0));
        lastYield = performance.now();
      }
    }

    async function dfs(){
      if (token !== solveToken) throw new Error('솔버 중지됨.');
      if (performance.now() > deadline) throw new Error('시간 제한 초과(솔버).');
      await maybeYield();

      const trail = [];
      if (!propagate(trail)){
        undo(trail);
        return;
      }

      if (allAssigned()){
        if (finalSingleLoop()){
          solCount++;
          if (found.length < 2) found.push(snapshot());
        }
        undo(trail);
        return;
      }

      const e = pickNextEdge();
      if (!e){
        undo(trail);
        return;
      }

      const order = [1,0];
      for (const val of order){
        const t2=[];
        if (!setS(e.kind,e.r,e.c,val,t2)){
          undo(t2);
          continue;
        }
        await dfs();
        undo(t2);

        if (mode === 'one' && solCount >= 1) break;
        if (mode === 'unique' && solCount >= 2) break;
      }

      undo(trail);
    }

    const initTrail = [];
    const ok = propagate(initTrail);
    if (!ok){
      undo(initTrail);
      return {count:0, sols:[]};
    }
    await dfs();
    undo(initTrail);

    return {count: solCount, sols: found};
  }

  function nextSolution(){
    if (solutions.length < 2) return;
    applySolutionIndex(solIndex + 1);
    setStatus(`해를 바꿨어요: ${solIndex+1}/${solutions.length}`);
  }

  // ---------- PNG 저장 ----------
  function cloneSvgForExport(kind){
    if (!svg) throw new Error('보드가 없습니다.');

    const cloned = svg.cloneNode(true);

    cloned.querySelectorAll('.edgeHit').forEach(n => n.remove());
    cloned.querySelectorAll('.cellHL').forEach(n => n.remove());

const w0 = Number(cloned.getAttribute('width'));
const h0 = Number(cloned.getAttribute('height'));
const M = 24;

// ✅ 헤더(시드/옵션) 줄 수에 따라 위 여백 늘리기
const includeMeta = (elPngIncludeSeed && elPngIncludeSeed.checked);
const headerLines = includeMeta ? 3 : 0;     // 3줄(좁은 보드에서도 안 잘리게)
const lineH = 18;                             // 한 줄 높이
const headerPad = includeMeta ? (12 + headerLines * lineH) : 0;

const w = w0 + M*2;
const h = h0 + M*2 + headerPad;               // ✅ 위쪽 공간 추가


    const outer = document.createElementNS('http://www.w3.org/2000/svg','svg');
    outer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    outer.setAttribute('width', String(w));
    outer.setAttribute('height', String(h));
    outer.setAttribute('viewBox', `0 0 ${w} ${h}`);

    const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0');
    bg.setAttribute('width', String(w));
    bg.setAttribute('height', String(h));
    bg.setAttribute('fill', '#ffffff');
    outer.appendChild(bg);

    const card = document.createElementNS('http://www.w3.org/2000/svg','rect');
    card.setAttribute('x', '8');
    card.setAttribute('y', '8');
    card.setAttribute('width', String(w-16));
    card.setAttribute('height', String(h-16));
    card.setAttribute('rx', '20');
    card.setAttribute('fill', '#ffffff');
    card.setAttribute('stroke', '#e5e7eb');
    card.setAttribute('stroke-width', '2');
    outer.appendChild(card);
// ✅ PNG에 시드/옵션 포함(한국어)
// ✅ PNG에 시드/옵션 포함(한국어, 3줄로 표시해서 안 잘리게)
if (elPngIncludeSeed && elPngIncludeSeed.checked) {
  const seedStr = (elSeed?.value || '').trim();
  const seedText = seedStr ? seedStr : '-';

  const diffText = elDiff?.options?.[elDiff.selectedIndex]?.text ?? '-';
  const densText = elDensity?.options?.[elDensity.selectedIndex]?.text ?? '-';
  const sizeText = `${R}x${C}`;
  const hideZeroText = (elHideZero && elHideZero.checked) ? '켜짐' : '꺼짐';

  const lines = [
    `시드: ${seedText} | 크기: ${sizeText}`,
    `난이도: ${diffText} | 힌트 밀도: ${densText}`,
    `0 숨기기: ${hideZeroText}`
  ];

  const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  t.setAttribute('x', '24');
  t.setAttribute('y', '34');
  t.setAttribute('fill', '#6b7280');
  t.setAttribute('font-size', '14');
  t.setAttribute('font-weight', '700');
  t.setAttribute('font-family', 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace');

  lines.forEach((s, i) => {
    const sp = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    sp.setAttribute('x', '24');
    sp.setAttribute('dy', i === 0 ? '0' : '18');
    sp.textContent = s;
    t.appendChild(sp);
  });

  outer.appendChild(t);
}




const g = document.createElementNS('http://www.w3.org/2000/svg','g');
g.setAttribute('transform', `translate(${M},${M + headerPad})`); // ✅ 헤더만큼 아래로

    while (cloned.firstChild) g.appendChild(cloned.firstChild);
    outer.appendChild(g);

    outer.querySelectorAll('circle.dot').forEach(n => n.setAttribute('fill', '#111827'));
    outer.querySelectorAll('text.clue').forEach(n => {
      n.setAttribute('fill', '#111827');
      n.setAttribute('font-size', '20');
      n.setAttribute('font-weight', '900');
      n.setAttribute('font-family', 'system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif');
      n.setAttribute('opacity', '0.95');
    });

    if (kind === 'puzzle'){
      outer.querySelectorAll('.edgeLine').forEach(n => n.remove());
      outer.querySelectorAll('.xMark').forEach(n => n.remove());
      outer.querySelectorAll('.solLine').forEach(n => n.remove());
    }

    if (kind === 'solution'){
      outer.querySelectorAll('.edgeLine').forEach(n => n.remove());
      outer.querySelectorAll('.xMark').forEach(n => n.remove());

      const solLines = Array.from(outer.querySelectorAll('.solLine'));
      const hCount = (R+1)*C;

      solLines.forEach((n, i) => {
        let on = false;
        if (solutions.length > 0){
          if (i < hCount){
            const rr = Math.floor(i / C);
            const cc = i % C;
            on = !!solutions[solIndex].h[rr][cc];
          } else {
            const j = i - hCount;
            const rr = Math.floor(j / (C+1));
            const cc = j % (C+1);
            on = !!solutions[solIndex].v[rr][cc];
          }
        }

        n.setAttribute('stroke', '#3b82f6');
        n.setAttribute('stroke-width', String(EDGEW));
        n.setAttribute('stroke-linecap', 'round');
        n.setAttribute('opacity', on ? '0.85' : '0');
      });
    }

    return outer;
  }

  async function svgToPngDownload(kind){
    const exportSvg = cloneSvgForExport(kind);
    const serializer = new XMLSerializer();
    const svgStr = serializer.serializeToString(exportSvg);
    const blob = new Blob([svgStr], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);

    try{
      const img = new Image();
      const p = new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () => reject(new Error('이미지 변환 실패'));
      });
      img.src = url;
      await p;

      const scale = 2;
      const w = Number(exportSvg.getAttribute('width'));
      const h = Number(exportSvg.getAttribute('height'));

      const canvas = document.createElement('canvas');
      canvas.width = Math.floor(w * scale);
      canvas.height = Math.floor(h * scale);

      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const pngUrl = canvas.toDataURL('image/png');

      const a = document.createElement('a');
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      const name = (kind === 'puzzle') ? `slither_puzzle_${stamp}.png` : `slither_solution_${stamp}.png`;
      a.href = pngUrl;
      a.download = name;
      a.click();
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  // ---------- 이벤트 ----------
  document.getElementById('loadBtn').addEventListener('click', loadPuzzle);
  document.getElementById('randomBtn').addEventListener('click', generateRandom);
  document.getElementById('checkBtn').addEventListener('click', checkAll);
  document.getElementById('clearLinesBtn').addEventListener('click', clearLines);
  document.getElementById('clearAllBtn').addEventListener('click', clearAll);

  document.getElementById('solveOneBtn').addEventListener('click', () => solve('one'));
  document.getElementById('solveUniqueBtn').addEventListener('click', () => solve('unique'));
  document.getElementById('stopSolveBtn').addEventListener('click', stopSolve);

  btnNextSol.addEventListener('click', nextSolution);

  document.getElementById('savePuzzlePngBtn').addEventListener('click', () => svgToPngDownload('puzzle'));
  document.getElementById('saveSolutionPngBtn').addEventListener('click', () => {
    if (solutions.length === 0){
      setStatus('솔루션이 없어요. 먼저 [해 1개 찾기] 또는 [유일성 검사]를 실행하세요.', false);
      return;
    }
    svgToPngDownload('solution');
  });

  elShowSol.addEventListener('change', () => redrawAll());
  elAuto.addEventListener('change', () => {
    if (elAuto.checked) checkAll();
    else setStatus('자동 검사는 꺼져 있어요. 필요할 때 [검사]를 누르세요.');
  });

  // 0 숨기기 토글 시: 표시만 바꾸고 싶으니 SVG를 다시 그려줌
  elHideZero.addEventListener('change', () => {
    buildSVG();
    setStatus('표시 옵션을 적용했어요.');
  });

  // ✅ 기본 상태: 자동검사 OFF, 솔루션 OFF
  elAuto.checked = false;
  elShowSol.checked = false;

  // 첫 시작: 빈 보드 표시
  clearAll();
})();
</script>
</body>
</html>
